<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farsinglish - ØªØ³Øª Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¢ÙÙ„Ø§ÛŒÙ†</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: #ecf0f1;
            min-height: 100vh;
            padding: 15px;
        }
        .container { 
            max-width: 900px; 
            margin: 0 auto;
            background: rgba(40, 50, 60, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(100, 150, 200, 0.2);
        }
        h1 { 
            text-align: center; 
            margin-bottom: 25px;
            font-size: 1.8rem;
            color: #3498db;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        h2 {
            margin: 20px 0 15px;
            color: #5dade2;
            font-size: 1.3rem;
            border-bottom: 2px solid #2980b9;
            padding-bottom: 8px;
        }
        .test-section { 
            margin: 15px 0;
            padding: 14px;
            background: rgba(50, 60, 70, 0.7);
            border-radius: 10px;
            border-left: 4px solid #3498db;
            transition: transform 0.2s;
        }
        .test-section:hover {
            transform: translateX(5px);
        }
        .test-header { 
            display: flex; 
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .test-title { 
            font-size: 0.95rem; 
            font-weight: 600;
            color: #d6eaf8;
        }
        .test-result { 
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        .pass { background: linear-gradient(45deg, #27ae60, #2ecc71); }
        .fail { background: linear-gradient(45deg, #c0392b, #e74c3c); }
        .details { 
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #abebc6;
            max-height: 200px;
            overflow-y: auto;
        }
        .summary {
            margin-top: 25px;
            padding: 18px;
            background: rgba(50, 60, 70, 0.8);
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        button {
            background: linear-gradient(45deg, #2980b9, #3498db);
            color: white;
            border: none;
            padding: 10px 22px;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            margin: 6px;
            font-weight: 600;
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }
        .controls { text-align: center; margin-top: 20px; }
        .network-status {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            margin: 10px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        .online { background: #27ae60; }
        .offline { background: #e74c3c; }
        .sync-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        .syncing { background: #f39c12; }
        .synced { background: #2ecc71; }
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        .demo-area {
            margin: 20px 0;
            padding: 15px;
            background: rgba(30, 40, 50, 0.8);
            border-radius: 10px;
            border: 1px solid #3498db;
        }
        @media (max-width: 600px) {
            .container { padding: 12px; }
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.1rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“¶ ØªØ³Øª Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¢ÙÙ„Ø§ÛŒÙ† - Farsinglish</h1>
        
        <div class="demo-area">
            <div id="network-status" class="network-status online">ğŸ”— Ø¢Ù†Ù„Ø§ÛŒÙ†</div>
            <div id="sync-status">
                <span class="sync-indicator synced"></span>
                <span>Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ: Ú©Ø§Ù…Ù„</span>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="simulateOffline()">ğŸ”Œ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¢ÙÙ„Ø§ÛŒÙ†</button>
                <button onclick="simulateOnline()">ğŸŒ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¢Ù†Ù„Ø§ÛŒÙ†</button>
                <button onclick="simulateSync()">ğŸ”„ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ</button>
            </div>
        </div>
        
        <h2>ğŸ—„ï¸ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¢ÙÙ„Ø§ÛŒÙ†</h2>
        <div id="storage-tests"></div>
        
        <h2>ğŸ”„ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ</h2>
        <div id="sync-tests"></div>
        
        <h2>ğŸš¨ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø®Ø·Ø§</h2>
        <div id="recovery-tests"></div>
        
        <h2>âš¡ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø¢ÙÙ„Ø§ÛŒÙ†</h2>
        <div id="performance-tests"></div>
        
        <div class="summary">
            <p id="summary-text">Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø¬Ø±Ø§ÛŒ Û±Û¶ ØªØ³Øª Ø¢ÙÙ„Ø§ÛŒÙ†...</p>
        </div>
        
        <div class="controls">
            <button onclick="runAllTests()">ğŸš€ Ø§Ø¬Ø±Ø§ÛŒ ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§</button>
            <button onclick="runOfflineDemo()">ğŸ’» Ù†Ù…Ø§ÛŒØ´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø¢ÙÙ„Ø§ÛŒÙ†</button>
            <button onclick="clearTests()">â™»ï¸ Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù†ØªØ§ÛŒØ¬</button>
        </div>
    </div>

    <script>
        // ==================== Offline Service ====================
        class OfflineService {
            constructor() {
                this.dbName = 'farsinglish-offline';
                this.dbVersion = 2;
                this.db = null;
                this.pendingOperations = [];
                this.syncQueue = [];
                this.lastSync = null;
                this.maxOfflineDays = 7;
                this.cacheSizeLimit = 50; // Ù…Ú¯Ø§Ø¨Ø§ÛŒØª
            }

            // ========== IndexedDB Management ==========
            async initDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ø¯ÛŒØªØ§Ø¨ÛŒØ³'));
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Ø§ÛŒØ¬Ø§Ø¯ Ø¬Ø¯Ø§ÙˆÙ„
                        if (!db.objectStoreNames.contains('lessons')) {
                            const lessonsStore = db.createObjectStore('lessons', { keyPath: 'id' });
                            lessonsStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                            lessonsStore.createIndex('level', 'level', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('userProgress')) {
                            const progressStore = db.createObjectStore('userProgress', { keyPath: 'userId' });
                            progressStore.createIndex('lastUpdated', 'lastUpdated', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('syncQueue')) {
                            const syncStore = db.createObjectStore('syncQueue', { keyPath: 'id', autoIncrement: true });
                            syncStore.createIndex('type', 'type', { unique: false });
                            syncStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('cache')) {
                            const cacheStore = db.createObjectStore('cache', { keyPath: 'key' });
                            cacheStore.createIndex('expires', 'expires', { unique: false });
                        }
                    };
                });
            }

            // ========== Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø±Ø³ ==========
            async saveLessonsOffline(lessons) {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    const transaction = this.db.transaction(['lessons'], 'readwrite');
                    const store = transaction.objectStore('lessons');
                    
                    const promises = lessons.map(lesson => {
                        const offlineLesson = {
                            ...lesson,
                            offline: true,
                            savedAt: Date.now(),
                            expires: Date.now() + (30 * 24 * 60 * 60 * 1000) // 30 Ø±ÙˆØ²
                        };
                        
                        return new Promise((resolve, reject) => {
                            const request = store.put(offlineLesson);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø±Ø³'));
                        });
                    });
                    
                    await Promise.all(promises);
                    return { success: true, count: lessons.length };
                } catch (error) {
                    console.error('Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ø¢ÙÙ„Ø§ÛŒÙ†:', error);
                    return { success: false, error: error.message };
                }
            }

            async getLessonsOffline(level = null) {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['lessons'], 'readonly');
                        const store = transaction.objectStore('lessons');
                        let request;
                        
                        if (level) {
                            const index = store.index('level');
                            request = index.getAll(level);
                        } else {
                            request = store.getAll();
                        }
                        
                        request.onsuccess = () => {
                            const lessons = request.result || [];
                            // ÙÛŒÙ„ØªØ± Ú©Ø±Ø¯Ù† Ù…ÙˆØ§Ø±Ø¯ Ù…Ù†Ù‚Ø¶ÛŒ
                            const validLessons = lessons.filter(lesson => 
                                !lesson.expires || lesson.expires > Date.now()
                            );
                            resolve({ success: true, lessons: validLessons });
                        };
                        
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† Ø¯Ø±Ø³â€ŒÙ‡Ø§'));
                    });
                } catch (error) {
                    return { success: false, error: error.message, lessons: [] };
                }
            }

            // ========== Ù¾ÛŒØ´Ø±ÙØª Ú©Ø§Ø±Ø¨Ø± ==========
            async saveUserProgress(userId, progress) {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['userProgress'], 'readwrite');
                        const store = transaction.objectStore('userProgress');
                        
                        const offlineProgress = {
                            userId,
                            ...progress,
                            offline: true,
                            lastUpdated: Date.now(),
                            syncRequired: true
                        };
                        
                        const request = store.put(offlineProgress);
                        
                        request.onsuccess = () => {
                            // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ ØµÙ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ
                            this.addToSyncQueue({
                                type: 'progress_update',
                                userId,
                                data: progress,
                                timestamp: Date.now()
                            });
                            resolve({ success: true });
                        };
                        
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ù¾ÛŒØ´Ø±ÙØª'));
                    });
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            async getUserProgress(userId) {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['userProgress'], 'readonly');
                        const store = transaction.objectStore('userProgress');
                        const request = store.get(userId);
                        
                        request.onsuccess = () => {
                            const progress = request.result;
                            if (progress) {
                                resolve({ success: true, progress });
                            } else {
                                resolve({ success: false, error: 'Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
                            }
                        };
                        
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† Ù¾ÛŒØ´Ø±ÙØª'));
                    });
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            // ========== Ù…Ø¯ÛŒØ±ÛŒØª ØµÙ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ==========
            async addToSyncQueue(item) {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['syncQueue'], 'readwrite');
                        const store = transaction.objectStore('syncQueue');
                        
                        const syncItem = {
                            ...item,
                            attempts: 0,
                            maxAttempts: 3,
                            status: 'pending'
                        };
                        
                        const request = store.add(syncItem);
                        
                        request.onsuccess = () => {
                            this.syncQueue.push(syncItem);
                            resolve({ success: true, id: request.result });
                        };
                        
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ ØµÙ'));
                    });
                } catch (error) {
                    console.error('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ø¨Ù‡ ØµÙ:', error);
                    return { success: false, error: error.message };
                }
            }

            async getPendingSyncItems() {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['syncQueue'], 'readonly');
                        const store = transaction.objectStore('syncQueue');
                        const index = store.index('timestamp');
                        const request = index.getAll();
                        
                        request.onsuccess = () => {
                            const items = request.result || [];
                            const pending = items.filter(item => item.status === 'pending');
                            resolve({ success: true, items: pending });
                        };
                        
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† ØµÙ'));
                    });
                } catch (error) {
                    return { success: false, error: error.message, items: [] };
                }
            }

            // ========== Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø§ Ø³Ø±ÙˆØ± ==========
            async syncWithServer() {
                if (!navigator.onLine) {
                    return { success: false, error: 'Ø¯Ø³ØªÚ¯Ø§Ù‡ Ø¢ÙÙ„Ø§ÛŒÙ† Ø§Ø³Øª', synced: false };
                }
                
                try {
                    const pendingItems = await this.getPendingSyncItems();
                    
                    if (!pendingItems.success || pendingItems.items.length === 0) {
                        return { success: true, synced: true, message: 'Ú†ÛŒØ²ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯' };
                    }
                    
                    let syncedCount = 0;
                    let failedCount = 0;
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ±
                    for (const item of pendingItems.items) {
                        try {
                            // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ API call
                            await this.simulateApiCall(item);
                            syncedCount++;
                            
                            // Ø­Ø°Ù Ø§Ø² ØµÙ Ø¨Ø¹Ø¯ Ø§Ø² Ù…ÙˆÙÙ‚ÛŒØª
                            await this.removeFromSyncQueue(item.id);
                        } catch (error) {
                            failedCount++;
                            item.attempts++;
                            
                            if (item.attempts >= item.maxAttempts) {
                                // Ù¾Ø³ Ø§Ø² Û³ Ø¨Ø§Ø± ØªÙ„Ø§Ø´ Ù†Ø§Ù…ÙˆÙÙ‚ØŒ Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯Ù‡
                                await this.markSyncItemFailed(item.id);
                            }
                        }
                    }
                    
                    this.lastSync = Date.now();
                    
                    return {
                        success: syncedCount > 0 || failedCount === 0,
                        synced: syncedCount > 0,
                        syncedCount,
                        failedCount,
                        lastSync: this.lastSync
                    };
                } catch (error) {
                    return { success: false, error: error.message, synced: false };
                }
            }

            async simulateApiCall(item) {
                // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ ØªØ§Ø®ÛŒØ± Ø´Ø¨Ú©Ù‡
                await new Promise(resolve => setTimeout(resolve, Math.random() * 300 + 100));
                
                // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø®Ø·Ø§ÛŒ ØªØµØ§Ø¯ÙÛŒ (Û²Û°Ùª Ø§Ø­ØªÙ…Ø§Ù„ Ø®Ø·Ø§)
                if (Math.random() < 0.2) {
                    throw new Error('Ø®Ø·Ø§ÛŒ Ø´Ø¨Ú©Ù‡ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡');
                }
                
                return { success: true };
            }

            async removeFromSyncQueue(id) {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['syncQueue'], 'readwrite');
                        const store = transaction.objectStore('syncQueue');
                        const request = store.delete(id);
                        
                        request.onsuccess = () => resolve({ success: true });
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø§Ø² ØµÙ'));
                    });
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            async markSyncItemFailed(id) {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['syncQueue'], 'readwrite');
                        const store = transaction.objectStore('syncQueue');
                        const getRequest = store.get(id);
                        
                        getRequest.onsuccess = () => {
                            const item = getRequest.result;
                            if (item) {
                                item.status = 'failed';
                                item.lastAttempt = Date.now();
                                const updateRequest = store.put(item);
                                updateRequest.onsuccess = () => resolve({ success: true });
                                updateRequest.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ'));
                            }
                        };
                        
                        getRequest.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† Ø¢ÛŒØªÙ…'));
                    });
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            // ========== Cache Management ==========
            async cacheData(key, data, ttl = 3600000) { // 1 hour default
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['cache'], 'readwrite');
                        const store = transaction.objectStore('cache');
                        
                        const cacheItem = {
                            key,
                            data: JSON.stringify(data),
                            cachedAt: Date.now(),
                            expires: Date.now() + ttl
                        };
                        
                        const request = store.put(cacheItem);
                        
                        request.onsuccess = () => resolve({ success: true });
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ú©Ø´'));
                    });
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            async getCachedData(key) {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['cache'], 'readonly');
                        const store = transaction.objectStore('cache');
                        const request = store.get(key);
                        
                        request.onsuccess = () => {
                            const item = request.result;
                            
                            if (!item) {
                                resolve({ success: false, error: 'Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø± Ú©Ø´ Ù†ÛŒØ³Øª' });
                                return;
                            }
                            
                            if (item.expires < Date.now()) {
                                // Ø­Ø°Ù Ø¯Ø§Ø¯Ù‡ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡
                                this.clearCacheKey(key);
                                resolve({ success: false, error: 'Ø¯Ø§Ø¯Ù‡ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡' });
                                return;
                            }
                            
                            try {
                                const data = JSON.parse(item.data);
                                resolve({ success: true, data, cachedAt: item.cachedAt });
                            } catch {
                                resolve({ success: false, error: 'Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡ Ú©Ø´' });
                            }
                        };
                        
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† Ú©Ø´'));
                    });
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            async clearExpiredCache() {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['cache'], 'readwrite');
                        const store = transaction.objectStore('cache');
                        const index = store.index('expires');
                        const range = IDBKeyRange.upperBound(Date.now());
                        const request = index.openCursor(range);
                        
                        let deletedCount = 0;
                        
                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                cursor.delete();
                                deletedCount++;
                                cursor.continue();
                            } else {
                                resolve({ success: true, deletedCount });
                            }
                        };
                        
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ú©Ø´'));
                    });
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            async clearCacheKey(key) {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(['cache'], 'readwrite');
                        const store = transaction.objectStore('cache');
                        const request = store.delete(key);
                        
                        request.onsuccess = () => resolve({ success: true });
                        request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø´'));
                    });
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            // ========== Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ ==========
            async backupUserData(userId) {
                try {
                    const [lessonsResult, progressResult] = await Promise.all([
                        this.getLessonsOffline(),
                        this.getUserProgress(userId)
                    ]);
                    
                    const backup = {
                        userId,
                        timestamp: Date.now(),
                        lessons: lessonsResult.lessons || [],
                        progress: progressResult.progress || null,
                        syncQueue: (await this.getPendingSyncItems()).items || []
                    };
                    
                    // Ø°Ø®ÛŒØ±Ù‡ Ø¨Ú©Ø§Ù¾ Ø¯Ø± localStorage (ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ ØªØ³Øª)
                    localStorage.setItem(`backup_${userId}`, JSON.stringify(backup));
                    
                    return {
                        success: true,
                        backup,
                        size: JSON.stringify(backup).length
                    };
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            async restoreFromBackup(userId) {
                try {
                    const backupStr = localStorage.getItem(`backup_${userId}`);
                    if (!backupStr) {
                        return { success: false, error: 'Ø¨Ú©Ø§Ù¾ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯' };
                    }
                    
                    const backup = JSON.parse(backupStr);
                    
                    // Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø¯Ø±Ø³â€ŒÙ‡Ø§
                    if (backup.lessons.length > 0) {
                        await this.saveLessonsOffline(backup.lessons);
                    }
                    
                    // Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù¾ÛŒØ´Ø±ÙØª
                    if (backup.progress) {
                        await this.saveUserProgress(userId, backup.progress);
                    }
                    
                    return {
                        success: true,
                        restored: {
                            lessons: backup.lessons.length,
                            progress: backup.progress ? 1 : 0
                        },
                        backupDate: new Date(backup.timestamp).toLocaleString('fa-IR')
                    };
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            // ========== Utilities ==========
            isOnline() {
                return navigator.onLine;
            }

            getStorageInfo() {
                if (!this.db) return { success: false, error: 'Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø§ÙˆÙ„ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù†Ø´Ø¯Ù‡' };
                
                const transaction = this.db.transaction(
                    ['lessons', 'userProgress', 'syncQueue', 'cache'], 
                    'readonly'
                );
                
                const promises = [
                    this.getObjectStoreCount(transaction.objectStore('lessons')),
                    this.getObjectStoreCount(transaction.objectStore('userProgress')),
                    this.getObjectStoreCount(transaction.objectStore('syncQueue')),
                    this.getObjectStoreCount(transaction.objectStore('cache'))
                ];
                
                return Promise.all(promises).then(counts => ({
                    success: true,
                    lessons: counts[0],
                    userProgress: counts[1],
                    syncQueue: counts[2],
                    cache: counts[3],
                    total: counts.reduce((a, b) => a + b, 0),
                    lastSync: this.lastSync ? new Date(this.lastSync).toLocaleString('fa-IR') : 'Ù‡Ø±Ú¯Ø²'
                }));
            }

            getObjectStoreCount(store) {
                return new Promise((resolve, reject) => {
                    const request = store.count();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø´Ù…Ø§Ø±Ø´'));
                });
            }

            async clearAllData() {
                try {
                    if (!this.db) await this.initDatabase();
                    
                    const stores = ['lessons', 'userProgress', 'syncQueue', 'cache'];
                    const results = {};
                    
                    for (const storeName of stores) {
                        const transaction = this.db.transaction([storeName], 'readwrite');
                        const store = transaction.objectStore(storeName);
                        const request = store.clear();
                        
                        await new Promise((resolve, reject) => {
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(new Error(`Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ ${storeName}`));
                        });
                        
                        results[storeName] = 'Ù¾Ø§Ú© Ø´Ø¯';
                    }
                    
                    return { success: true, results };
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }
        }

        // ==================== ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¢ÙÙ„Ø§ÛŒÙ† ====================
        const offlineService = new OfflineService();
        
        const storageTests = [
            {
                id: 'st-1',
                title: 'Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒ Ø¢ÙÙ„Ø§ÛŒÙ†',
                run: async () => {
                    const lessons = [
                        { id: 1, title: 'Ø¯Ø±Ø³ Û±', level: 1, content: 'Ù…Ø­ØªÙˆØ§ Û±' },
                        { id: 2, title: 'Ø¯Ø±Ø³ Û²', level: 1, content: 'Ù…Ø­ØªÙˆØ§ Û²' },
                        { id: 3, title: 'Ø¯Ø±Ø³ Û³', level: 2, content: 'Ù…Ø­ØªÙˆØ§ Û³' }
                    ];
                    
                    const result = await offlineService.saveLessonsOffline(lessons);
                    return result.success && result.count === 3;
                }
            },
            {
                id: 'st-2',
                title: 'Ø®ÙˆØ§Ù†Ø¯Ù† Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒ Ø¢ÙÙ„Ø§ÛŒÙ†',
                run: async () => {
                    const result = await offlineService.getLessonsOffline();
                    return result.success && Array.isArray(result.lessons);
                }
            },
            {
                id: 'st-3',
                title: 'ÙÛŒÙ„ØªØ± Ø¯Ø±Ø³â€ŒÙ‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø³Ø·Ø­',
                run: async () => {
                    const result = await offlineService.getLessonsOffline(1);
                    return result.success && 
                           result.lessons.every(lesson => lesson.level === 1);
                }
            },
            {
                id: 'st-4',
                title: 'Ø°Ø®ÛŒØ±Ù‡ Ù¾ÛŒØ´Ø±ÙØª Ú©Ø§Ø±Ø¨Ø± Ø¢ÙÙ„Ø§ÛŒÙ†',
                run: async () => {
                    const progress = {
                        level: 3,
                        xp: 1200,
                        completedLessons: [1, 2, 3],
                        lastActivity: Date.now()
                    };
                    
                    const result = await offlineService.saveUserProgress('test-user-123', progress);
                    return result.success;
                }
            }
        ];

        const syncTests = [
            {
                id: 'sy-1',
                title: 'Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ù‡ ØµÙ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ',
                run: async () => {
                    const result = await offlineService.addToSyncQueue({
                        type: 'test_sync',
                        data: { test: 'data' },
                        timestamp: Date.now()
                    });
                    
                    return result.success && typeof result.id === 'number';
                }
            },
            {
                id: 'sy-2',
                title: 'Ø®ÙˆØ§Ù†Ø¯Ù† Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ',
                run: async () => {
                    const result = await offlineService.getPendingSyncItems();
                    return result.success && Array.isArray(result.items);
                }
            },
            {
                id: 'sy-3',
                title: 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø§ Ø³Ø±ÙˆØ± (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ)',
                run: async () => {
                    const result = await offlineService.syncWithServer();
                    return result.success === true;
                }
            },
            {
                id: 'sy-4',
                title: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø´',
                run: async () => {
                    const testData = { message: 'Ø¯Ø§Ø¯Ù‡ ØªØ³Øª Ú©Ø´' };
                    
                    // Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ú©Ø´
                    const saveResult = await offlineService.cacheData('test-key', testData, 60000);
                    if (!saveResult.success) return false;
                    
                    // Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø² Ú©Ø´
                    const readResult = await offlineService.getCachedData('test-key');
                    
                    return readResult.success && 
                           readResult.data.message === 'Ø¯Ø§Ø¯Ù‡ ØªØ³Øª Ú©Ø´';
                }
            }
        ];

        const recoveryTests = [
            {
                id: 'rc-1',
                title: 'Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø² Ø¨Ú©Ø§Ù¾',
                run: async () => {
                    const result = await offlineService.restoreFromBackup('test-user-123');
                    return result.success || result.error === 'Ø¨Ú©Ø§Ù¾ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯';
                }
            },
            {
                id: 'rc-2',
                title: 'Ø§ÛŒØ¬Ø§Ø¯ Ø¨Ú©Ø§Ù¾',
                run: async () => {
                    const result = await offlineService.backupUserData('test-user-123');
                    return result.success;
                }
            },
            {
                id: 'rc-3',
                title: 'Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ú©Ø´ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡',
                run: async () => {
                    // Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡ Ø¨Ø§ Ø²Ù…Ø§Ù† Ø§Ù†Ù‚Ø¶Ø§ÛŒ Ú¯Ø°Ø´ØªÙ‡
                    await offlineService.cacheData('expired-key', { data: 'Ù…Ù†Ù‚Ø¶ÛŒ' }, -1000);
                    
                    const result = await offlineService.clearExpiredCache();
                    return result.success;
                }
            },
            {
                id: 'rc-4',
                title: 'Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ',
                run: async () => {
                    const result = await offlineService.getStorageInfo();
                    return result.success && typeof result.total === 'number';
                }
            }
        ];

        const performanceTests = [
            {
                id: 'pf-1',
                title: 'Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ø¬Ù… Ø²ÛŒØ§Ø¯ (Û±Û°Û° Ø¯Ø±Ø³)',
                run: async () => {
                    const lessons = [];
                    for (let i = 1; i <= 100; i++) {
                        lessons.push({
                            id: 1000 + i,
                            title: `Ø¯Ø±Ø³ Ø­Ø¬Ù…ÛŒ ${i}`,
                            level: Math.ceil(i / 20),
                            content: 'Ù…Ø­ØªÙˆØ§ ØªØ³Øª '.repeat(10),
                            vocabulary: Array(20).fill().map((_, idx) => ({
                                english: `Word${idx}`,
                                persian: `Ú©Ù„Ù…Ù‡ ${idx}`
                            }))
                        });
                    }
                    
                    const start = performance.now();
                    const result = await offlineService.saveLessonsOffline(lessons);
                    const end = performance.now();
                    const duration = end - start;
                    
                    console.log('Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Û±Û°Û° Ø¯Ø±Ø³:', { duration: `${duration.toFixed(2)}ms` });
                    
                    return result.success && duration < 5000; // Ú©Ù…ØªØ± Ø§Ø² Ûµ Ø«Ø§Ù†ÛŒÙ‡
                }
            },
            {
                id: 'pf-2',
                title: 'Ø®ÙˆØ§Ù†Ø¯Ù† Ù‡Ù…Ø²Ù…Ø§Ù†',
                run: async () => {
                    const start = performance.now();
                    
                    const [lessonsResult, progressResult, syncResult] = await Promise.all([
                        offlineService.getLessonsOffline(),
                        offlineService.getUserProgress('test-user-123'),
                        offlineService.getPendingSyncItems()
                    ]);
                    
                    const end = performance.now();
                    const duration = end - start;
                    
                    console.log('Ø®ÙˆØ§Ù†Ø¯Ù† Ù‡Ù…Ø²Ù…Ø§Ù†:', { duration: `${duration.toFixed(2)}ms` });
                    
                    return lessonsResult.success &&
                           progressResult.success !== undefined &&
                           syncResult.success &&
                           duration < 3000; // Ú©Ù…ØªØ± Ø§Ø² Û³ Ø«Ø§Ù†ÛŒÙ‡
                }
            },
            {
                id: 'pf-3',
                title: 'Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ø§Ù„Øª Ø¢ÙÙ„Ø§ÛŒÙ†',
                run: async () => {
                    const originalOnline = navigator.onLine;
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¢ÙÙ„Ø§ÛŒÙ†
                    Object.defineProperty(navigator, 'onLine', { value: false, configurable: true });
                    
                    const syncResult = await offlineService.syncWithServer();
                    
                    // Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª
                    Object.defineProperty(navigator, 'onLine', { value: originalOnline, configurable: true });
                    
                    return !syncResult.synced && syncResult.error.includes('Ø¢ÙÙ„Ø§ÛŒÙ†');
                }
            },
            {
                id: 'pf-4',
                title: 'Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ Ø¯Ø§Ø¯Ù‡',
                run: async () => {
                    const result = await offlineService.clearAllData();
                    return result.success;
                }
            }
        ];

        // ==================== Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ ====================
        async function runAllTests() {
            clearTestAreas();
            await offlineService.initDatabase();
            
            const allTests = [
                ...storageTests,
                ...syncTests,
                ...recoveryTests,
                ...performanceTests
            ];
            
            let passed = 0;
            let total = 0;
            
            // Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ
            for (const test of storageTests) {
                await executeTest(test, 'storage-tests');
                total++;
                if (await test.run()) passed++;
            }
            
            // Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ
            for (const test of syncTests) {
                await executeTest(test, 'sync-tests');
                total++;
                if (await test.run()) passed++;
            }
            
            // Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ
            for (const test of recoveryTests) {
                await executeTest(test, 'recovery-tests');
                total++;
                if (await test.run()) passed++;
            }
            
            // Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯
            for (const test of performanceTests) {
                await executeTest(test, 'performance-tests');
                total++;
                if (await test.run()) passed++;
            }
            
            updateSummary(passed, total);
        }
        
        async function executeTest(test, containerId) {
            const container = document.getElementById(containerId);
            const testDiv = document.createElement('div');
            testDiv.className = 'test-section';
            
            try {
                const result = await test.run();
                testDiv.innerHTML = `
                    <div class="test-header">
                        <div class="test-title">${test.id}. ${test.title}</div>
                        <div class="test-result ${result ? 'pass' : 'fail'}">
                            ${result ? 'âœ…' : 'âŒ'}
                        </div>
                    </div>
                `;
            } catch (error) {
                testDiv.innerHTML = `
                    <div class="test-header">
                        <div class="test-title">${test.id}. ${test.title}</div>
                        <div class="test-result fail">âŒ Ø®Ø·Ø§</div>
                    </div>
                    <div class="details">${error.message}</div>
                `;
            }
            
            container.appendChild(testDiv);
        }
        
        async function runOfflineDemo() {
            const demoArea = document.querySelector('.demo-area');
            const originalHTML = demoArea.innerHTML;
            
            demoArea.innerHTML = `
                <h3>ğŸ’» Ù†Ù…Ø§ÛŒØ´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø¢ÙÙ„Ø§ÛŒÙ†</h3>
                <div id="demo-output" style="margin-top: 10px;"></div>
            `;
            
            const output = document.getElementById('demo-output');
            
            // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¬Ø±ÛŒØ§Ù† Ø¢ÙÙ„Ø§ÛŒÙ†
            output.innerHTML = '<p>ğŸ“¥ Ø¯Ø± Ø­Ø§Ù„ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¢ÙÙ„Ø§ÛŒÙ†...</p>';
            
            // Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡
            const lessons = [
                { id: 101, title: 'Ø­ÛŒÙˆØ§Ù†Ø§Øª', level: 1, words: ['Cat', 'Dog', 'Bird'] },
                { id: 102, title: 'Ø±Ù†Ú¯â€ŒÙ‡Ø§', level: 1, words: ['Red', 'Blue', 'Green'] }
            ];
            
            await offlineService.saveLessonsOffline(lessons);
            
            output.innerHTML += '<p>âœ… Ø¯Ø±Ø³â€ŒÙ‡Ø§ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù†Ø¯</p>';
            output.innerHTML += '<p>ğŸ“Š Ø¯Ø± Ø­Ø§Ù„ Ø°Ø®ÛŒØ±Ù‡ Ù¾ÛŒØ´Ø±ÙØª Ú©Ø§Ø±Ø¨Ø±...</p>';
            
            // Ø°Ø®ÛŒØ±Ù‡ Ù¾ÛŒØ´Ø±ÙØª
            const progress = {
                level: 2,
                xp: 450,
                completedLessons: [101],
                currentLesson: 102
            };
            
            await offlineService.saveUserProgress('demo-user', progress);
            
            output.innerHTML += '<p>âœ… Ù¾ÛŒØ´Ø±ÙØª Ú©Ø§Ø±Ø¨Ø± Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯</p>';
            output.innerHTML += '<p>ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ù‡ ØµÙ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ...</p>';
            
            // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ ØµÙ sync
            await offlineService.addToSyncQueue({
                type: 'progress_sync',
                userId: 'demo-user',
                timestamp: Date.now()
            });
            
            output.innerHTML += '<p>âœ… Ø¨Ù‡ ØµÙ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯</p>';
            
            // Ù†Ù…Ø§ÛŒØ´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª
            const storageInfo = await offlineService.getStorageInfo();
            
            output.innerHTML += `
                <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                    <strong>ğŸ“ˆ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ:</strong><br>
                    Ø¯Ø±Ø³â€ŒÙ‡Ø§: ${storageInfo.lessons || 0}<br>
                    Ù¾ÛŒØ´Ø±ÙØª Ú©Ø§Ø±Ø¨Ø±: ${storageInfo.userProgress || 0}<br>
                    Ø¯Ø± ØµÙ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ: ${storageInfo.syncQueue || 0}<br>
                    ÙˆØ¶Ø¹ÛŒØª: ${offlineService.isOnline() ? 'ğŸŒ Ø¢Ù†Ù„Ø§ÛŒÙ†' : 'ğŸ”Œ Ø¢ÙÙ„Ø§ÛŒÙ†'}
                </div>
            `;
            
            setTimeout(() => {
                demoArea.innerHTML = originalHTML;
            }, 5000);
        }
        
        function simulateOffline() {
            document.getElementById('network-status').className = 'network-status offline';
            document.getElementById('network-status').textContent = 'ğŸ”Œ Ø¢ÙÙ„Ø§ÛŒÙ†';
            
            const syncIndicator = document.querySelector('.sync-indicator');
            syncIndicator.className = 'sync-indicator syncing';
            
            const syncStatus = document.getElementById('sync-status').querySelector('span:last-child');
            syncStatus.textContent = 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ: Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø§ØªØµØ§Ù„';
            
            console.log('Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ø§Ù„Øª Ø¢ÙÙ„Ø§ÛŒÙ†');
        }
        
        function simulateOnline() {
            document.getElementById('network-status').className = 'network-status online';
            document.getElementById('network-status').textContent = 'ğŸ”— Ø¢Ù†Ù„Ø§ÛŒÙ†';
            
            console.log('Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ø§Ù„Øª Ø¢Ù†Ù„Ø§ÛŒÙ†');
        }
        
        async function simulateSync() {
            const syncIndicator = document.querySelector('.sync-indicator');
            syncIndicator.className = 'sync-indicator syncing';
            
            const syncStatus = document.getElementById('sync-status').querySelector('span:last-child');
            syncStatus.textContent = 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ: Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…...';
            
            // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ ØªØ§Ø®ÛŒØ±
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            const result = await offlineService.syncWithServer();
            
            if (result.synced) {
                syncIndicator.className = 'sync-indicator synced';
                syncStatus.textContent = `Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ: Ú©Ø§Ù…Ù„ (${result.syncedCount} Ø¢ÛŒØªÙ…)`;
            } else {
                syncIndicator.className = 'sync-indicator';
                syncIndicator.style.background = '#e74c3c';
                syncStatus.textContent = 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ: Ù†Ø§Ù…ÙˆÙÙ‚';
            }
        }
        
        function updateSummary(passed, total) {
            const percentage = total > 0 ? Math.round((passed / total) * 100) : 0;
            const summary = document.getElementById('summary-text');
            
            summary.innerHTML = `
                <strong>Ù†ØªØ§ÛŒØ¬ ØªØ³Øª Ø¢ÙÙ„Ø§ÛŒÙ†:</strong><br>
                âœ… ${passed} Ù…ÙˆÙÙ‚ | âŒ ${total - passed} Ù†Ø§Ù…ÙˆÙÙ‚ | ğŸ“Š ${percentage}% Ù‚Ø¨ÙˆÙ„ÛŒ<br>
                ${percentage === 100 ? 'ğŸ‰ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø¢ÙÙ„Ø§ÛŒÙ† Ø¹Ø§Ù„ÛŒ!' : ''}
            `;
            
            summary.style.color = percentage >= 90 ? '#27ae60' : 
                                 percentage >= 70 ? '#f39c12' : '#e74c3c';
        }
        
        function clearTestAreas() {
            ['storage-tests', 'sync-tests', 'recovery-tests', 'performance-tests']
                .forEach(id => {
                    document.getElementById(id).innerHTML = '';
                });
        }
        
        function clearTests() {
            clearTestAreas();
            document.getElementById('summary-text').innerHTML = 'Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø¬Ø±Ø§ÛŒ Û±Û¶ ØªØ³Øª Ø¢ÙÙ„Ø§ÛŒÙ†...';
            document.getElementById('summary-text').style.color = '#ecf0f1';
        }

        // Ø§Ø¬Ø±Ø§ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± ØªØ³Øªâ€ŒÙ‡Ø§
        window.onload = async () => {
            updateSummary(0, 0);
            
            // Ø§ÙˆÙ„ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø³Ø±ÙˆÛŒØ³
            try {
                await offlineService.initDatabase();
                console.log('âœ… Ø³Ø±ÙˆÛŒØ³ Ø¢ÙÙ„Ø§ÛŒÙ† Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª');
                setTimeout(runAllTests, 1000);
            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ø§ÙˆÙ„ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ:', error);
            }
        };
    </script>
</body>
</html>
