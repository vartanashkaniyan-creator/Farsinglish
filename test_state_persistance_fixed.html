<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farsinglish - ØªØ³Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ State (Ù†Ø³Ø®Ù‡ Ø§ØµÙ„Ø§Ø­â€ŒØ´Ø¯Ù‡)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #0c2461 0%, #1e3799 100%);
            color: #f8f8f8;
            min-height: 100vh;
            padding: 15px;
        }
        .container { 
            max-width: 900px; 
            margin: 0 auto;
            background: rgba(15, 20, 40, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(86, 98, 246, 0.3);
        }
        h1 { 
            text-align: center; 
            margin-bottom: 25px;
            font-size: 1.8rem;
            color: #5699f6;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .test-section { 
            margin: 15px 0;
            padding: 15px;
            background: rgba(30, 35, 70, 0.85);
            border-radius: 10px;
            border-left: 4px solid #ff6b6b;
            transition: all 0.3s;
        }
        .test-section:hover {
            background: rgba(40, 45, 80, 0.95);
            transform: translateY(-2px);
        }
        .test-header { 
            display: flex; 
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .test-title { 
            font-size: 1rem; 
            font-weight: 600;
            color: #bb86fc;
        }
        .test-result { 
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        .pass { background: linear-gradient(45deg, #00c853, #64dd17); }
        .fail { background: linear-gradient(45deg, #d50000, #ff5252); }
        .details { 
            margin-top: 10px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #a5d6a7;
            border: 1px solid rgba(100, 150, 100, 0.2);
            max-height: 150px;
            overflow-y: auto;
        }
        .summary {
            margin-top: 20px;
            padding: 15px;
            background: rgba(25, 35, 70, 0.9);
            border-radius: 10px;
            text-align: center;
            font-size: 0.95rem;
            border: 1px solid rgba(86, 98, 246, 0.3);
        }
        button {
            background: linear-gradient(45deg, #8e2de2, #4a00e0);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
            font-weight: 600;
        }
        button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(142, 45, 226, 0.5);
        }
        .controls { text-align: center; margin-top: 20px; }
        .state-viewer {
            background: rgba(0, 10, 30, 0.7);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .state-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .state-key { color: #bb86fc; font-size: 0.9rem; }
        .state-value { color: #4fc3f7; font-size: 0.85rem; }
        .simulator {
            background: rgba(0, 15, 35, 0.7);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid rgba(86, 98, 246, 0.4);
        }
        .sim-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }
        .sim-btn {
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            flex: 1;
            min-width: 120px;
        }
        .sim-btn.delete {
            background: linear-gradient(45deg, #f44336, #ff7961);
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-online { background: #4caf50; }
        .status-offline { background: #f44336; }
        @media (max-width: 600px) {
            .container { padding: 12px; }
            .test-header { flex-direction: column; align-items: flex-start; }
            .sim-buttons { flex-direction: column; }
            .sim-btn { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ’¾ ØªØ³Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ State - Ù†Ø³Ø®Ù‡ Ø§ØµÙ„Ø§Ø­â€ŒØ´Ø¯Ù‡</h1>
        
        <div class="simulator">
            <h3 style="text-align: center; color: #4fc3f7; margin-bottom: 15px;">
                <span class="status-indicator status-online"></span>Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø² State
            </h3>
            <div class="sim-buttons">
                <button class="sim-btn" onclick="simulateUserLogin()">ğŸ‘¤ ÙˆØ±ÙˆØ¯ Ú©Ø§Ø±Ø¨Ø±</button>
                <button class="sim-btn" onclick="simulateLessonProgress()">ğŸ“š Ù¾ÛŒØ´Ø±ÙØª Ø¯Ø±Ø³</button>
                <button class="sim-btn" onclick="simulateSettingsChange()">âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª</button>
                <button class="sim-btn" onclick="simulateBackupRecovery()">ğŸ”„ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ</button>
                <button class="sim-btn delete" onclick="clearAllStates()">ğŸ—‘ï¸ Ø­Ø°Ù Ù‡Ù…Ù‡</button>
            </div>
            <div class="state-viewer">
                <h4>ğŸ“‹ StateÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡â€ŒØ´Ø¯Ù‡:</h4>
                <div id="current-state"></div>
            </div>
        </div>
        
        <div id="test-results"></div>
        
        <div class="summary">
            <p id="summary-text">Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø¬Ø±Ø§ÛŒ Û±Û² ØªØ³Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ...</p>
            <div id="error-log" style="font-size: 0.8rem; color: #ff6b6b; margin-top: 10px;"></div>
        </div>
        
        <div class="controls">
            <button onclick="runAllTests()">ğŸš€ Ø§Ø¬Ø±Ø§ÛŒ ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§</button>
            <button onclick="clearTests()" style="background: linear-gradient(45deg, #757575, #9e9e9e);">â™»ï¸ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ù†Ù…Ø§ÛŒØ´</button>
            <button onclick="debugDatabase()" style="background: linear-gradient(45deg, #ff9800, #ffb74d);">ğŸ› Ø¯ÛŒØ¨Ø§Ú¯ Ø¯ÛŒØªØ§Ø¨ÛŒØ³</button>
        </div>
    </div>

    <script>
        // ==================== State Persistence Service - Ù†Ø³Ø®Ù‡ Ø§ØµÙ„Ø§Ø­â€ŒØ´Ø¯Ù‡ ====================
        class StatePersistenceServiceFixed {
            constructor() {
                this.dbName = 'farsinglish_state_v2';
                this.dbVersion = 2; // Ù†Ø³Ø®Ù‡ Ø§ÙØ²Ø§ÛŒØ´ ÛŒØ§ÙØªÙ‡
                this.storeName = 'app_states';
                this.backupStore = 'state_backups';
                this.db = null;
                this.initialized = false;
                this.errorLog = [];
            }

            // ========== IndexedDB Management ==========
            async initDatabase() {
                if (this.initialized && this.db) {
                    return this.db;
                }
                
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = (event) => {
                        const error = `Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ø¯ÛŒØªØ§Ø¨ÛŒØ³: ${event.target.error}`;
                        this.logError(error);
                        reject(new Error(error));
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        this.initialized = true;
                        this.logInfo('âœ… Ø¯ÛŒØªØ§Ø¨ÛŒØ³ State Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯');
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Ø§ÛŒØ¬Ø§Ø¯ store Ø§ØµÙ„ÛŒ
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                            store.createIndex('stateType', 'stateType', { unique: false });
                            store.createIndex('backupFor', 'backupFor', { unique: false });
                            this.logInfo('ğŸ“¦ ObjectStore Ø§ØµÙ„ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯');
                        }
                        
                        // Ø§ÛŒØ¬Ø§Ø¯ store Ø¨Ø±Ø§ÛŒ backupÙ‡Ø§
                        if (!db.objectStoreNames.contains(this.backupStore)) {
                            const backupStore = db.createObjectStore(this.backupStore, { keyPath: 'id' });
                            backupStore.createIndex('originalId', 'originalId', { unique: false });
                            backupStore.createIndex('backupTime', 'backupTime', { unique: false });
                            this.logInfo('ğŸ’¾ Backup store Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯');
                        }
                    };
                    
                    request.onblocked = () => {
                        this.logError('âš ï¸ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù…Ø³Ø¯ÙˆØ¯ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§ ØªØ¨â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒÚ¯Ø± Ø±Ø§ Ø¨Ø¨Ù†Ø¯ÛŒØ¯.');
                    };
                });
            }

            // ========== State Operations ==========
            async saveState(stateId, stateData, metadata = {}) {
                try {
                    if (!this.initialized) await this.initDatabase();
                    
                    // Ø§ÛŒØ¬Ø§Ø¯ backup Ù‚Ø¨Ù„ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡
                    if (metadata.autoBackup !== false) {
                        await this.createBackup(stateId, stateData, metadata);
                    }
                    
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    
                    const stateRecord = {
                        id: stateId,
                        data: this.deepClone(stateData),
                        timestamp: Date.now(),
                        stateType: metadata.type || 'general',
                        version: metadata.version || '1.0',
                        checksum: this.calculateChecksum(stateData),
                        metadata: {
                            ...metadata,
                            savedAt: new Date().toISOString()
                        }
                    };
                    
                    return new Promise((resolve, reject) => {
                        const request = store.put(stateRecord);
                        
                        request.onsuccess = () => {
                            this.logInfo(`âœ… State "${stateId}" Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯`);
                            resolve(stateRecord);
                        };
                        
                        request.onerror = (event) => {
                            const error = `Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ State "${stateId}": ${event.target.error}`;
                            this.logError(error);
                            reject(new Error(error));
                        };
                    });
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± saveState: ${error.message}`);
                    throw error;
                }
            }

            async loadState(stateId) {
                try {
                    if (!this.initialized) await this.initDatabase();
                    
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.get(stateId);
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result) {
                                // Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ checksum
                                const currentChecksum = this.calculateChecksum(result.data);
                                if (currentChecksum !== result.checksum) {
                                    this.logError(`âš ï¸ Checksum State "${stateId}" Ù…Ø·Ø§Ø¨Ù‚Øª Ù†Ø¯Ø§Ø±Ø¯`);
                                }
                                
                                this.logInfo(`ğŸ“¥ State "${stateId}" Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯`);
                                resolve(result);
                            } else {
                                resolve(null);
                            }
                        };
                        
                        request.onerror = (event) => {
                            const error = `Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ State "${stateId}": ${event.target.error}`;
                            this.logError(error);
                            reject(new Error(error));
                        };
                    });
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± loadState: ${error.message}`);
                    throw error;
                }
            }

            async deleteState(stateId) {
                try {
                    if (!this.initialized) await this.initDatabase();
                    
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.delete(stateId);
                        
                        request.onsuccess = () => {
                            this.logInfo(`ğŸ—‘ï¸ State "${stateId}" Ø­Ø°Ù Ø´Ø¯`);
                            resolve(true);
                        };
                        
                        request.onerror = (event) => {
                            const error = `Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù State "${stateId}": ${event.target.error}`;
                            this.logError(error);
                            reject(new Error(error));
                        };
                    });
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± deleteState: ${error.message}`);
                    throw error;
                }
            }

            async getAllStates() {
                try {
                    if (!this.initialized) await this.initDatabase();
                    
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.getAll();
                        
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = (event) => {
                            const error = `Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª StateÙ‡Ø§: ${event.target.error}`;
                            this.logError(error);
                            reject(new Error(error));
                        };
                    });
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± getAllStates: ${error.message}`);
                    throw error;
                }
            }

            async clearAllStates() {
                try {
                    if (!this.initialized) await this.initDatabase();
                    
                    const transaction = this.db.transaction([this.storeName, this.backupStore], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const backupStore = transaction.objectStore(this.backupStore);
                    
                    return new Promise((resolve, reject) => {
                        const clearMain = store.clear();
                        const clearBackup = backupStore.clear();
                        
                        clearMain.onsuccess = clearBackup.onsuccess = () => {
                            this.logInfo('ğŸ§¹ ØªÙ…Ø§Ù… StateÙ‡Ø§ Ùˆ BackupÙ‡Ø§ Ø­Ø°Ù Ø´Ø¯Ù†Ø¯');
                            resolve(true);
                        };
                        
                        clearMain.onerror = clearBackup.onerror = (event) => {
                            const error = `Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù StateÙ‡Ø§: ${event.target.error}`;
                            this.logError(error);
                            reject(new Error(error));
                        };
                    });
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± clearAllStates: ${error.message}`);
                    throw error;
                }
            }

            // ========== Backup & Recovery - Ù†Ø³Ø®Ù‡ Ø§ØµÙ„Ø§Ø­â€ŒØ´Ø¯Ù‡ ==========
            async createBackup(originalId, stateData, metadata = {}) {
                try {
                    if (!this.initialized) await this.initDatabase();
                    
                    const backupId = `backup_${originalId}_${Date.now()}`;
                    const transaction = this.db.transaction([this.backupStore], 'readwrite');
                    const store = transaction.objectStore(this.backupStore);
                    
                    const backupRecord = {
                        id: backupId,
                        originalId: originalId,
                        data: this.deepClone(stateData),
                        backupTime: Date.now(),
                        checksum: this.calculateChecksum(stateData),
                        metadata: {
                            ...metadata,
                            backupReason: 'auto_backup',
                            backedUpAt: new Date().toISOString()
                        }
                    };
                    
                    return new Promise((resolve, reject) => {
                        const request = store.put(backupRecord);
                        
                        request.onsuccess = () => {
                            this.logInfo(`ğŸ’¾ Backup Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯: ${backupId}`);
                            resolve(backupRecord);
                        };
                        
                        request.onerror = (event) => {
                            this.logError(`Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ backup: ${event.target.error}`);
                            reject(new Error('Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ backup'));
                        };
                    });
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± createBackup: ${error.message}`);
                    return null;
                }
            }

            async recoverFromBackup(stateId) {
                try {
                    if (!this.initialized) await this.initDatabase();
                    
                    // Ø§ÙˆÙ„ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù† State Ø§ØµÙ„ÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯ ÛŒØ§ Ù†Ù‡
                    const currentState = await this.loadState(stateId);
                    if (currentState) {
                        this.logInfo(`âœ… State "${stateId}" Ø§Ø² Ù‚Ø¨Ù„ Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³Øª`);
                        return currentState;
                    }
                    
                    // Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± backupÙ‡Ø§
                    const transaction = this.db.transaction([this.backupStore], 'readonly');
                    const store = transaction.objectStore(this.backupStore);
                    const index = store.index('originalId');
                    
                    return new Promise((resolve, reject) => {
                        const request = index.getAll(stateId);
                        
                        request.onsuccess = () => {
                            const backups = request.result;
                            
                            if (backups.length === 0) {
                                this.logWarn(`âš ï¸ Ù‡ÛŒÚ† backupÛŒ Ø¨Ø±Ø§ÛŒ "${stateId}" ÛŒØ§ÙØª Ù†Ø´Ø¯`);
                                resolve(null);
                                return;
                            }
                            
                            this.logInfo(`ğŸ” ${backups.length} backup Ø¨Ø±Ø§ÛŒ "${stateId}" ÛŒØ§ÙØª Ø´Ø¯`);
                            
                            // Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø²Ù…Ø§Ù† (Ø¬Ø¯ÛŒØ¯ØªØ±ÛŒÙ† Ø§ÙˆÙ„)
                            backups.sort((a, b) => b.backupTime - a.backupTime);
                            
                            // Ø¨Ø±Ø±Ø³ÛŒ checksum Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø§ÙˆÙ„ÛŒÙ† backup Ù…Ø¹ØªØ¨Ø±
                            for (const backup of backups) {
                                try {
                                    const checksum = this.calculateChecksum(backup.data);
                                    if (checksum === backup.checksum) {
                                        this.logInfo(`ğŸ”„ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø² backup: ${backup.id}`);
                                        
                                        // Ø°Ø®ÛŒØ±Ù‡ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† State Ø§ØµÙ„ÛŒ
                                        const recoveredState = {
                                            id: stateId,
                                            data: backup.data,
                                            timestamp: Date.now(),
                                            stateType: backup.metadata?.type || 'recovered',
                                            checksum: backup.checksum,
                                            metadata: {
                                                ...backup.metadata,
                                                recoveredFrom: backup.id,
                                                recoveryTime: Date.now(),
                                                originalBackupTime: backup.backupTime
                                            }
                                        };
                                        
                                        // Ø°Ø®ÛŒØ±Ù‡ State Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯Ù‡
                                        this.saveState(stateId, recoveredState.data, recoveredState.metadata)
                                            .then(() => resolve(recoveredState))
                                            .catch(error => {
                                                this.logError(`Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ State Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯Ù‡: ${error.message}`);
                                                resolve(backup); // Ø­Ø¯Ø§Ù‚Ù„ backup Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†
                                            });
                                        
                                        return;
                                    } else {
                                        this.logWarn(`âš ï¸ Checksum backup ${backup.id} Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª`);
                                    }
                                } catch (error) {
                                    this.logWarn(`âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ backup ${backup.id}: ${error.message}`);
                                }
                            }
                            
                            // Ø§Ú¯Ø± Ù‡ÛŒÚ† backup Ù…Ø¹ØªØ¨Ø±ÛŒ Ù†Ø¨ÙˆØ¯
                            this.logWarn('âš ï¸ Ù‡ÛŒÚ† backup Ù…Ø¹ØªØ¨Ø±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯');
                            resolve(null);
                        };
                        
                        request.onerror = (event) => {
                            const error = `Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ backupÙ‡Ø§: ${event.target.error}`;
                            this.logError(error);
                            reject(new Error(error));
                        };
                    });
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± recoverFromBackup: ${error.message}`);
                    return null;
                }
            }

            // ========== Utility Methods ==========
            deepClone(obj) {
                try {
                    if (obj === null || typeof obj !== 'object') return obj;
                    return JSON.parse(JSON.stringify(obj));
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± deepClone: ${error.message}`);
                    return obj;
                }
            }

            calculateChecksum(data) {
                try {
                    const json = JSON.stringify(data);
                    let hash = 0;
                    for (let i = 0; i < json.length; i++) {
                        const char = json.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash;
                    }
                    return Math.abs(hash).toString(16);
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± calculateChecksum: ${error.message}`);
                    return 'error';
                }
            }

            generateStateId(prefix = 'state') {
                const randomStr = Math.random().toString(36).substring(2, 10);
                return `${prefix}_${Date.now()}_${randomStr}`;
            }

            async getDatabaseInfo() {
                try {
                    if (!this.initialized) await this.initDatabase();
                    
                    const [states, backups] = await Promise.all([
                        this.getAllStates(),
                        this.getAllBackups()
                    ]);
                    
                    const totalSize = JSON.stringify(states).length + JSON.stringify(backups).length;
                    
                    return {
                        totalStates: states.length,
                        totalBackups: backups.length,
                        totalSizeKB: (totalSize / 1024).toFixed(2),
                        stateTypes: [...new Set(states.map(s => s.stateType))],
                        lastBackup: backups.length > 0 ? 
                            new Date(Math.max(...backups.map(b => b.backupTime))) : 
                            null
                    };
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± getDatabaseInfo: ${error.message}`);
                    throw error;
                }
            }

            async getAllBackups() {
                try {
                    if (!this.initialized) await this.initDatabase();
                    
                    const transaction = this.db.transaction([this.backupStore], 'readonly');
                    const store = transaction.objectStore(this.backupStore);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = (event) => reject(event.target.error);
                    });
                } catch (error) {
                    this.logError(`Ø®Ø·Ø§ Ø¯Ø± getAllBackups: ${error.message}`);
                    return [];
                }
            }

            // ========== Logging ==========
            logInfo(message) {
                console.log(`â„¹ï¸ ${message}`);
            }

            logWarn(message) {
                console.warn(`âš ï¸ ${message}`);
                this.errorLog.push({ type: 'warn', message, time: Date.now() });
            }

            logError(message) {
                console.error(`âŒ ${message}`);
                this.errorLog.push({ type: 'error', message, time: Date.now() });
                this.updateErrorDisplay();
            }

            getErrorLog() {
                return this.errorLog;
            }

            clearErrorLog() {
                this.errorLog = [];
                this.updateErrorDisplay();
            }

            updateErrorDisplay() {
                const errorDiv = document.getElementById('error-log');
                if (errorDiv) {
                    const errors = this.errorLog.slice(-3);
                    if (errors.length > 0) {
                        errorDiv.innerHTML = errors.map(e => 
                            `<div style="margin: 2px 0;">${e.type === 'error' ? 'âŒ' : 'âš ï¸'} ${e.message}</div>`
                        ).join('');
                    } else {
                        errorDiv.innerHTML = '';
                    }
                }
            }
        }

        // ==================== ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„Ø§Ø­â€ŒØ´Ø¯Ù‡ ====================
        const persistenceTestsFixed = [
            {
                id: 1,
                title: "Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ State Ú©Ø§Ø±Ø¨Ø±",
                run: async (service) => {
                    const userState = {
                        user: {
                            id: "user_123_fixed",
                            username: "Ø¹Ù„ÛŒ Ù…Ø­Ù…Ø¯ÛŒ",
                            level: 5,
                            xp: 1250
                        }
                    };
                    
                    const stateId = service.generateStateId('user');
                    await service.saveState(stateId, userState, { 
                        type: 'user', 
                        version: '1.1' 
                    });
                    
                    const loaded = await service.loadState(stateId);
                    return loaded && 
                           loaded.data.user.username === "Ø¹Ù„ÛŒ Ù…Ø­Ù…Ø¯ÛŒ" &&
                           loaded.data.user.level === 5;
                }
            },
            {
                id: 2,
                title: "Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ State Ø¯Ø±Ø³",
                run: async (service) => {
                    const lessonState = {
                        currentLesson: {
                            id: "lesson_456_fixed",
                            title: "Ù…Ú©Ø§Ù„Ù…Ù‡ Ø±ÙˆØ²Ù…Ø±Ù‡",
                            progress: 75
                        }
                    };
                    
                    const stateId = "lesson_current_fixed";
                    await service.saveState(stateId, lessonState, { type: 'lesson' });
                    
                    const loaded = await service.loadState(stateId);
                    return loaded && 
                           loaded.data.currentLesson.progress === 75 &&
                           loaded.data.currentLesson.title === "Ù…Ú©Ø§Ù„Ù…Ù‡ Ø±ÙˆØ²Ù…Ø±Ù‡";
                }
            },
            {
                id: 3,
                title: "Ø­Ø°Ù State",
                run: async (service) => {
                    const tempState = { test: "Ø­Ø°Ù Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯" };
                    const stateId = "temp_state_to_delete_fixed";
                    
                    await service.saveState(stateId, tempState, { type: 'test' });
                    await service.deleteState(stateId);
                    
                    const loaded = await service.loadState(stateId);
                    return loaded === null;
                }
            },
            {
                id: 4,
                title: "Ø¯Ø±ÛŒØ§ÙØª Ù‡Ù…Ù‡ StateÙ‡Ø§",
                run: async (service) => {
                    // Ø§ÛŒØ¬Ø§Ø¯ Ú†Ù†Ø¯ State Ø¨Ø±Ø§ÛŒ ØªØ³Øª
                    await service.saveState("test_state_1", { data: "Ø§ÙˆÙ„" }, { type: 'test' });
                    await service.saveState("test_state_2", { data: "Ø¯ÙˆÙ…" }, { type: 'test' });
                    
                    const allStates = await service.getAllStates();
                    const testStates = allStates.filter(s => s.stateType === 'test');
                    return testStates.length >= 2;
                }
            },
            {
                id: 5,
                title: "Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø§ Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§ÛŒ ÙØ§Ø±Ø³ÛŒ",
                run: async (service) => {
                    const farsiState = {
                        title: "Ø¯Ø±Ø³ ÙØ§Ø±Ø³ÛŒ",
                        description: "Ø§ÛŒÙ† ÛŒÚ© ØªÙˆØ¶ÛŒØ­ ÙØ§Ø±Ø³ÛŒ Ø§Ø³Øª Ø¨Ø±Ø§ÛŒ ØªØ³Øª",
                        data: {
                            Ù†Ú©Ø§Øª: ["Ù†Ú©ØªÙ‡ Ø§ÙˆÙ„", "Ù†Ú©ØªÙ‡ Ø¯ÙˆÙ…"],
                            Ù†Ù…ÙˆÙ†Ù‡: "Ù…ØªÙ† Ù†Ù…ÙˆÙ†Ù‡ ÙØ§Ø±Ø³ÛŒ"
                        }
                    };
                    
                    const stateId = "farsi_test_fixed";
                    await service.saveState(stateId, farsiState, { type: 'farsi' });
                    
                    const loaded = await service.loadState(stateId);
                    return loaded && 
                           loaded.data.title === "Ø¯Ø±Ø³ ÙØ§Ø±Ø³ÛŒ" &&
                           loaded.data.description.includes("ÙØ§Ø±Ø³ÛŒ");
                }
            },
            {
                id: 6,
                title: "Checksum Ø¨Ø±Ø§ÛŒ ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ Ø¯Ø§Ø¯Ù‡",
                run: async (service) => {
                    const testState = { important: "Ø¯Ø§Ø¯Ù‡ Ù…Ù‡Ù…", number: 42 };
                    const stateId = "checksum_test_fixed";
                    
                    const saved = await service.saveState(stateId, testState);
                    const loaded = await service.loadState(stateId);
                    
                    return saved && loaded && 
                           saved.checksum === loaded.checksum &&
                           loaded.checksum === service.calculateChecksum(testState);
                }
            },
            {
                id: 7,
                title: "Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø² Backup - Ù†Ø³Ø®Ù‡ Ø§ØµÙ„Ø§Ø­â€ŒØ´Ø¯Ù‡",
                run: async (service) => {
                    const stateId = "recovery_test_fixed";
                    
                    // Ø­Ø°Ù StateÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
                    await service.deleteState(stateId);
                    
                    // Ø§ÛŒØ¬Ø§Ø¯ State Ø§ØµÙ„ÛŒ
                    const originalState = { 
                        user: "Ú©Ø§Ø±Ø¨Ø± Ø§ØµÙ„ÛŒ",
                        data: "Ø¯Ø§Ø¯Ù‡ Ø§ØµÙ„ÛŒ",
                        timestamp: Date.now()
                    };
                    
                    await service.saveState(stateId, originalState, { 
                        type: 'user_data',
                        important: true
                    });
                    
                    // ØµØ¨Ø± Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ backup
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Ø­Ø°Ù State Ø§ØµÙ„ÛŒ (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø² Ø¯Ø³Øª Ø±ÙØªÙ†)
                    await service.deleteState(stateId);
                    
                    // Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ
                    const recovered = await service.recoverFromBackup(stateId);
                    
                    // Ø¨Ø§ÛŒØ¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´ÙˆØ¯
                    return recovered !== null && 
                           recovered.data.user === "Ú©Ø§Ø±Ø¨Ø± Ø§ØµÙ„ÛŒ" &&
                           recovered.metadata.recoveredFrom !== undefined;
                }
            },
            {
                id: 8,
                title: "State Ø¨Ø²Ø±Ú¯ (Performance Test)",
                run: async (service) => {
                    // Ø§ÛŒØ¬Ø§Ø¯ State Ø¨Ø§ Ø­Ø¬Ù… Ù†Ø³Ø¨ØªØ§Ù‹ Ø¨Ø²Ø±Ú¯
                    const largeState = {
                        vocabulary: Array.from({ length: 50 }, (_, i) => ({
                            id: `word_${i}`,
                            english: `word${i}`,
                            persian: `Ú©Ù„Ù…Ù‡ ${i}`,
                            mastered: i % 3 === 0
                        })),
                        metadata: {
                            totalWords: 50,
                            lastUpdate: new Date().toISOString()
                        }
                    };
                    
                    const stateId = "large_state_fixed";
                    const startTime = performance.now();
                    
                    await service.saveState(stateId, largeState, { type: 'vocabulary' });
                    const loaded = await service.loadState(stateId);
                    
                    const endTime = performance.now();
                    const duration = endTime - startTime;
                    
                    console.log(`â±ï¸ Ø²Ù…Ø§Ù† ØªØ³Øª: ${duration.toFixed(2)}ms`);
                    
                    return loaded && 
                           loaded.data.vocabulary.length === 50 &&
                           duration < 3000; // Ø¨Ø§ÛŒØ¯ Ø²ÛŒØ± Û³ Ø«Ø§Ù†ÛŒÙ‡ Ø¨Ø§Ø´Ø¯
                }
            },
            {
                id: 9,
                title: "Deep Clone ØµØ­ÛŒØ­",
                run: async (service) => {
                    const original = {
                        nested: {
                            data: "Ø§ØµÙ„ÛŒ",
                            numbers: [1, 2, 3]
                        }
                    };
                    
                    const cloned = service.deepClone(original);
                    cloned.nested.data = "ØªØºÛŒÛŒØ± ÛŒØ§ÙØªÙ‡";
                    cloned.nested.numbers.push(4);
                    
                    // original Ù†Ø¨Ø§ÛŒØ¯ ØªØºÛŒÛŒØ± Ú©Ø±Ø¯Ù‡ Ø¨Ø§Ø´Ø¯
                    return original.nested.data === "Ø§ØµÙ„ÛŒ" &&
                           original.nested.numbers.length === 3;
                }
            },
            {
                id: 10,
                title: "Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯ÛŒØªØ§Ø¨ÛŒØ³",
                run: async (service) => {
                    // Ø§ÛŒØ¬Ø§Ø¯ StateÙ‡Ø§ÛŒ ØªØ³Øª
                    await service.saveState("info_test_1", { test: 1 }, { type: 'test' });
                    await service.saveState("info_test_2", { test: 2 }, { type: 'test' });
                    
                    const info = await service.getDatabaseInfo();
                    return info.totalStates >= 2 &&
                           info.stateTypes.includes('test');
                }
            },
            {
                id: 11,
                title: "Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§ - Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ State Ù†Ø§Ù…ÙˆØ¬ÙˆØ¯",
                run: async (service) => {
                    const nonExistentId = "non_existent_state_xyz";
                    const recovered = await service.recoverFromBackup(nonExistentId);
                    
                    // Ø¨Ø§ÛŒØ¯ null Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯ (Ù†Ù‡ Ø®Ø·Ø§)
                    return recovered === null;
                }
            },
            {
                id: 12,
                title: "Auto Backup",
                run: async (service) => {
                    const stateId = "auto_backup_test";
                    const testState = { data: "ØªØ³Øª auto backup" };
                    
                    await service.saveState(stateId, testState, { 
                        type: 'test',
                        autoBackup: true
                    });
                    
                    // ØµØ¨Ø± Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ backup
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    // Ø­Ø°Ù State Ø§ØµÙ„ÛŒ
                    await service.deleteState(stateId);
                    
                    // Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø¨Ø§ÛŒØ¯ Ú©Ø§Ø± Ú©Ù†Ø¯
                    const recovered = await service.recoverFromBackup(stateId);
                    return recovered !== null;
                }
            }
        ];

        // ==================== Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø² ====================
        const stateService = new StatePersistenceServiceFixed();

        async function simulateUserLogin() {
            const userState = {
                user: {
                    id: "sim_user_" + Date.now(),
                    username: "Ú©Ø§Ø±Ø¨Ø± ØªØ³Øª",
                    level: Math.floor(Math.random() * 10) + 1,
                    loginTime: new Date().toISOString()
                }
            };
            
            const stateId = stateService.generateStateId('user_session');
            await stateService.saveState(stateId, userState, { 
                type: 'user_session',
                autoBackup: true
            });
            
            updateStateViewer();
            showMessage(`ğŸ‘¤ State Ú©Ø§Ø±Ø¨Ø± Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ (${stateId})`);
        }

        async function simulateLessonProgress() {
            const lessonState = {
                lesson: {
                    id: "lesson_" + Math.floor(Math.random() * 1000),
                    title: ["Ù…Ú©Ø§Ù„Ù…Ù‡", "Ú¯Ø±Ø§Ù…Ø±", "ÙˆØ§Ú˜Ú¯Ø§Ù†"][Math.floor(Math.random() * 3)],
                    progress: Math.floor(Math.random() * 100),
                    score: Math.floor(Math.random() * 100)
                }
            };
            
            const stateId = stateService.generateStateId('lesson_progress');
            await stateService.saveState(stateId, lessonState, { 
                type: 'lesson_progress',
                autoBackup: true
            });
            
            updateStateViewer();
            showMessage(`ğŸ“š State Ø¯Ø±Ø³ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ (${stateId})`);
        }

        async function simulateSettingsChange() {
            const settingsState = {
                preferences: {
                    theme: ['dark', 'light'][Math.floor(Math.random() * 2)],
                    language: 'fa',
                    fontSize: 14
                }
            };
            
            const stateId = "user_settings";
            await stateService.saveState(stateId, settingsState, { 
                type: 'settings',
                autoBackup: true
            });
            
            updateStateViewer();
            showMessage(`âš™ï¸ State ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯`);
        }

        async function simulateBackupRecovery() {
            const stateId = "backup_recovery_demo";
            
            // Ø§ÛŒØ¬Ø§Ø¯ State
            const demoState = { 
                message: "Ø§ÛŒÙ† State Ø¨Ø±Ø§ÛŒ ØªØ³Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡",
                timestamp: Date.now()
            };
            
            await stateService.saveState(stateId, demoState, { 
                type: 'demo',
                autoBackup: true
            });
            
            // Ø­Ø°Ù
            await stateService.deleteState(stateId);
            
            // Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ
            const recovered = await stateService.recoverFromBackup(stateId);
            
            if (recovered) {
                showMessage(`ğŸ”„ State Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯ Ø§Ø²: ${recovered.metadata.recoveredFrom}`);
            } else {
                showMessage(`âš ï¸ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯`);
            }
            
            updateStateViewer();
        }

        async function clearAllStates() {
            await stateService.clearAllStates();
            updateStateViewer();
            showMessage('ğŸ—‘ï¸ ØªÙ…Ø§Ù… StateÙ‡Ø§ Ø­Ø°Ù Ø´Ø¯Ù†Ø¯');
        }

        async function updateStateViewer() {
            try {
                const states = await stateService.getAllStates();
                const container = document.getElementById('current-state');
                
                if (states.length === 0) {
                    container.innerHTML = '<div style="color: #888; text-align: center;">Ù‡ÛŒÚ† StateØ§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª</div>';
                    return;
                }
                
                let html = '';
                states.slice(-5).reverse().forEach(state => {
                    const time = new Date(state.timestamp).toLocaleTimeString();
                    const size = JSON.stringify(state.data).length;
                    
                    html += `
                        <div class="state-item">
                            <div class="state-key">${state.id.substring(0, 20)}...</div>
                            <div class="state-value">
                                ${state.stateType} â€¢ ${time} â€¢ ${size} Ø¨Ø§ÛŒØª
                            </div>
                        </div>
                    `;
                });
                
                if (states.length > 5) {
                    html += `<div style="color: #888; text-align: center; padding: 10px;">
                        + ${states.length - 5} State Ø¯ÛŒÚ¯Ø±
                    </div>`;
                }
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± updateStateViewer:', error);
            }
        }

        function showMessage(text) {
            console.log('ğŸ’¬ ' + text);
            const summary = document.getElementById('summary-text');
            const originalHTML = summary.innerHTML;
            summary.innerHTML = `<span style="color: #4fc3f7; font-weight: bold;">${text}</span><br>${originalHTML}`;
            
            setTimeout(() => {
                summary.innerHTML = originalHTML;
            }, 3000);
        }

        async function debugDatabase() {
            try {
                const info = await stateService.getDatabaseInfo();
                const errors = stateService.getErrorLog();
                
                console.group('ğŸ› Ø¯ÛŒØ¨Ø§Ú¯ Ø¯ÛŒØªØ§Ø¨ÛŒØ³');
                console.log('ğŸ“Š Ø§Ø·Ù„Ø§Ø¹Ø§Øª:', info);
                console.log('ğŸ“ Ø®Ø·Ø§Ù‡Ø§ÛŒ Ø§Ø®ÛŒØ±:', errors.slice(-5));
                console.groupEnd();
                
                showMessage(`ğŸ› Ø¯ÛŒØ¨Ø§Ú¯: ${info.totalStates} State, ${errors.length} Ø®Ø·Ø§`);
            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ø¯ÛŒØ¨Ø§Ú¯:', error);
                showMessage('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯ÛŒØ¨Ø§Ú¯');
            }
        }

        // ==================== Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ ====================
        let passedTests = 0;
        let failedTests = 0;

        async function runAllTests() {
            passedTests = 0;
            failedTests = 0;
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '';
            
            // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ø®Ø·Ø§Ù‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
            stateService.clearErrorLog();
            
            for (const test of persistenceTestsFixed) {
                try {
                    console.log(`ğŸ§ª Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª ${test.id}: ${test.title}`);
                    const result = await test.run(stateService);
                    
                    const testDiv = document.createElement('div');
                    testDiv.className = 'test-section';
                    
                    const testResult = result ? 'pass' : 'fail';
                    const resultText = result ? 'âœ… Ù…ÙˆÙÙ‚' : 'âŒ Ù†Ø§Ù…ÙˆÙÙ‚';
                    
                    if (result) passedTests++;
                    else failedTests++;
                    
                    testDiv.innerHTML = `
                        <div class="test-header">
                            <div class="test-title">${test.id}. ${test.title}</div>
                            <div class="test-result ${testResult}">${resultText}</div>
                        </div>
                    `;
                    
                    resultsDiv.appendChild(testDiv);
                    
                } catch (error) {
                    failedTests++;
                    const testDiv = document.createElement('div');
                    testDiv.className = 'test-section';
                    testDiv.innerHTML = `
                        <div class="test-header">
                            <div class="test-title">${test.id}. ${test.title}</div>
                            <div class="test-result fail">âŒ Ø®Ø·Ø§</div>
                        </div>
                        <div class="details">${error.message}</div>
                    `;
                    resultsDiv.appendChild(testDiv);
                    console.error(`âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª ${test.id}:`, error);
                }
                
                updateSummary();
            }
            
            // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†Ù…Ø§ÛŒØ´ StateÙ‡Ø§
            updateStateViewer();
            
            // Ù†Ù…Ø§ÛŒØ´ Ù†ØªÛŒØ¬Ù‡ Ù†Ù‡Ø§ÛŒÛŒ
            const percentage = Math.round((passedTests / persistenceTestsFixed.length) * 100);
            const finalMessage = percentage === 100 ? 'ğŸ‰ ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§ Ù…ÙˆÙÙ‚!' :
                                percentage >= 80 ? 'âœ… Ø§Ú©Ø«Ø± ØªØ³Øªâ€ŒÙ‡Ø§ Ù…ÙˆÙÙ‚' :
                                'âš ï¸ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø±Ø³ÛŒ';
            
            showMessage(`${finalMessage} (${passedTests}/${persistenceTestsFixed.length} - ${percentage}%)`);
        }

        function clearTests() {
            document.getElementById('test-results').innerHTML = '';
            passedTests = failedTests = 0;
            updateSummary();
        }

        function updateSummary() {
            const summary = document.getElementById('summary-text');
            const total = persistenceTestsFixed.length;
            const percentage = total > 0 ? Math.round((passedTests / total) * 100) : 0;
            
            summary.innerHTML = `
                <strong>Ù†ØªÛŒØ¬Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ State:</strong><br>
                âœ… ${passedTests} Ù…ÙˆÙÙ‚ | âŒ ${failedTests} Ù†Ø§Ù…ÙˆÙÙ‚ | ğŸ“Š ${percentage}% Ù‚Ø¨ÙˆÙ„ÛŒ
            `;
            
            // ØªØºÛŒÛŒØ± Ø±Ù†Ú¯ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¯Ø±ØµØ¯
            summary.style.color = percentage === 100 ? '#4caf50' : 
                                 percentage >= 80 ? '#ff9800' : '#f44336';
        }

        // Ø§Ø¬Ø±Ø§ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±
        window.onload = async () => {
            try {
                await stateService.initDatabase();
                updateSummary();
                updateStateViewer();
                
                // Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ Ø¨Ø§ ØªØ£Ø®ÛŒØ±
                setTimeout(() => {
                    showMessage('ğŸš€ Ø´Ø±ÙˆØ¹ ØªØ³Øªâ€ŒÙ‡Ø§ Ø¯Ø± Û³ Ø«Ø§Ù†ÛŒÙ‡...');
                    setTimeout(runAllTests, 3000);
                }, 1000);
                
            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§ÙˆÙ„ÛŒÙ‡:', error);
                document.getElementById('summary-text').innerHTML = 
                    `<span style="color: #f44336;">âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ: ${error.message}</span>`;
            }
        };
    </script>
</body>
</html>
