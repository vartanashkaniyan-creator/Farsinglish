```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØ³Øª SRS Engine Pro - Ù†Ø³Ø®Ù‡ Ù¾ÛŒØ´Ø±ÙØªÙ‡</title>
    <style>
        body {
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 20px auto;
            padding: 0 20px;
            direction: ltr;
            background: #f0f4f8;
        }
        h1 {
            color: #1e3c5c;
            font-size: 2rem;
            border-bottom: 3px solid #3498db;
            padding-bottom: 8px;
        }
        h2 {
            color: #2c3e50;
            font-size: 1.4rem;
            margin: 25px 0 15px;
            border-right: 4px solid #3498db;
            padding-right: 12px;
        }
        .summary {
            background: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            font-size: 1.1rem;
        }
        .summary-pass { color: #27ae60; font-weight: bold; }
        .summary-fail { color: #e74c3c; font-weight: bold; }
        .test-list {
            background: white;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 25px;
        }
        .test-item {
            padding: 15px 20px;
            border-bottom: 1px solid #ecf0f1;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .test-item:last-child { border-bottom: none; }
        .test-status {
            width: 95px;
            text-align: center;
            padding: 5px 10px;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .status-pass {
            background: #d5f5e3;
            color: #186a3b;
        }
        .status-fail {
            background: #fadbd8;
            color: #943126;
        }
        .test-name {
            flex: 1;
            font-weight: 500;
            color: #1e3c5c;
        }
        .test-message {
            font-size: 0.9rem;
            color: #566573;
            margin-top: 5px;
            font-family: monospace;
        }
        .button-container {
            display: flex;
            gap: 15px;
            margin: 25px 0;
            flex-wrap: wrap;
        }
        .primary-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 40px;
            font-size: 1.1rem;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(52,152,219,0.3);
        }
        .primary-btn:hover { background: #2980b9; }
        .secondary-btn {
            background: #7f8c8d;
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 40px;
            font-size: 1.1rem;
            cursor: pointer;
            font-weight: 600;
        }
        .secondary-btn:hover { background: #6c7a7d; }
        .note {
            background: #ebf5fb;
            border-left: 6px solid #3498db;
            padding: 18px 22px;
            border-radius: 16px;
            margin: 25px 0;
            font-size: 1rem;
            color: #1b4e6f;
            line-height: 1.6;
        }
        .algorithm-badge {
            display: inline-block;
            background: #3498db;
            color: white;
            padding: 4px 12px;
            border-radius: 30px;
            font-size: 0.85rem;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <h1>ğŸ§ª ØªØ³Øª SRS Engine Pro <span class="algorithm-badge">SM-2 Â· Anki Â· FSRS</span></h1>
    <p style="color: #2c3e50; margin-bottom: 25px; font-size: 1.1rem;">ØªØ³Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ…â€ŒÙ‡Ø§ + Ø¢Ù…Ø§Ø± ØªØ­Ù„ÛŒÙ„ÛŒ Â· Ø§Ø¬Ø±Ø§ÛŒ Ø¯Ø³ØªÛŒ Ø¨Ø§ Ø¯Ú©Ù…Ù‡</p>

    <div class="summary">
        <span>ğŸ“Š Ù…Ø¬Ù…ÙˆØ¹ ØªØ³Øªâ€ŒÙ‡Ø§: <span id="total">0</span></span>
        <span>âœ… Ù…ÙˆÙÙ‚: <span id="passed" class="summary-pass">0</span></span>
        <span>âŒ Ù†Ø§Ù…ÙˆÙÙ‚: <span id="failed" class="summary-fail">0</span></span>
    </div>

    <div class="button-container">
        <button class="primary-btn" onclick="runAllTests()">â–¶ Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø¬Ø¯Ø¯ Ù‡Ù…Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§</button>
        <button class="secondary-btn" onclick="window.location.reload()">ğŸ”„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø¬Ø¯Ø¯ ØµÙØ­Ù‡</button>
    </div>

    <h2>ğŸ”¹ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… SM-2 (Ù¾Ø§ÛŒÙ‡)</h2>
    <div class="test-list" id="test-list-sm2"></div>

    <h2>ğŸ”¸ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Anki (4 Ú¯Ø²ÛŒÙ†Ù‡)</h2>
    <div class="test-list" id="test-list-anki"></div>

    <h2>ğŸ”¹ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… FSRS (Ù¾ÛŒØ´Ø±ÙØªÙ‡)</h2>
    <div class="test-list" id="test-list-fsrs"></div>

    <h2>ğŸ“Š Ø¢Ù…Ø§Ø± ØªØ­Ù„ÛŒÙ„ÛŒ</h2>
    <div class="test-list" id="test-list-metrics"></div>

    <div class="note">
        <strong>ğŸ” ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù†Ø³Ø®Ù‡ Pro:</strong><br>
        â€¢ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² Û³ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ…: SM-2 Ú©Ù„Ø§Ø³ÛŒÚ©ØŒ Anki (Û´ Ú¯Ø²ÛŒÙ†Ù‡)ØŒ FSRS Ù…Ø¨ØªÙ†ÛŒ Ø¨Ø± Ø­Ø§ÙØ¸Ù‡<br>
        â€¢ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù…Ø§Ø± retentionØŒ stability Ùˆ difficulty<br>
        â€¢ Ù¾Ø±Ø§Ú©Ù†Ø¯Ú¯ÛŒ ØªØµØ§Ø¯ÙÛŒ (Fuzzing) Ø¨Ø±Ø§ÛŒ ÙÙˆØ§ØµÙ„ Ø¨Ø§Ù„Ø§ØªØ±<br>
        â€¢ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§ Ùˆ Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ<br>
        â€¢ Ù‡Ù…Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§ Ø¨Ø§ Ø¯Ú©Ù…Ù‡ Ø¯Ø³ØªÛŒ Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
    </div>

    <script>
        (function() {
            // ==================== Ù…Ø§Ú˜ÙˆÙ„ SRS Engine Pro ====================
            const DEFAULTS = {
                MIN_EASE_FACTOR: 1.3,
                MAX_EASE_FACTOR: 5.0,
                DEFAULT_EASE_FACTOR: 2.5,
                INTERVAL_REP_0: 1,
                INTERVAL_REP_1: 6,
                MAX_INTERVAL: 36500,
                EASE_BONUS: 0.15,
                EASE_PENALTY: 0.2,
                HARD_PENALTY: 0.1,
                AGAIN_MULTIPLIER: 0.5,
                HARD_MULTIPLIER: 1.2,
                GOOD_MULTIPLIER: 2.5,
                EASY_MULTIPLIER: 3.0
            };

            const ReviewQuality = {
                AGAIN: 0, HARD: 1, GOOD: 2, EASY: 3, PERFECT: 4
            };

            const AlgorithmType = {
                SM2: 'sm2', ANKI: 'anki', FSRS: 'fsrs'
            };

            class SRSEngine {
                constructor(config = {}) {
                    this.config = {
                        algorithm: config.algorithm || AlgorithmType.SM2,
                        maxInterval: config.maxInterval || DEFAULTS.MAX_INTERVAL,
                        enableFuzzing: config.enableFuzzing || false,
                        fuzzRange: config.fuzzRange || 0.05,
                        ...config
                    };
                }

                calculate(quality, currentData) {
                    this._validateInput(quality, currentData);
                    switch (this.config.algorithm) {
                        case AlgorithmType.ANKI: return this._calculateAnki(quality, currentData);
                        case AlgorithmType.FSRS: return this._calculateFSRS(quality, currentData);
                        default: return this._calculateSM2(quality, currentData);
                    }
                }

                _calculateSM2(quality, currentData) {
                    const { repetition = 0, easeFactor = DEFAULTS.DEFAULT_EASE_FACTOR, interval = 0, lapses = 0, reviewHistory = [] } = currentData;
                    let newEaseFactor = easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
                    newEaseFactor = Math.max(DEFAULTS.MIN_EASE_FACTOR, Math.min(DEFAULTS.MAX_EASE_FACTOR, newEaseFactor));
                    let newRepetition, newInterval;
                    if (quality >= 3) {
                        newRepetition = repetition + 1;
                        if (newRepetition === 1) newInterval = DEFAULTS.INTERVAL_REP_0;
                        else if (newRepetition === 2) newInterval = DEFAULTS.INTERVAL_REP_1;
                        else newInterval = Math.round(interval * newEaseFactor);
                    } else {
                        newRepetition = 0;
                        newInterval = 1;
                    }
                    if (this.config.enableFuzzing && newInterval > 10) newInterval = this._applyFuzzing(newInterval);
                    newInterval = Math.min(newInterval, this.config.maxInterval);
                    const newData = {
                        repetition: newRepetition,
                        easeFactor: Number(newEaseFactor.toFixed(2)),
                        interval: newInterval,
                        lapses: quality < 3 ? lapses + 1 : lapses,
                        lastDuration: currentData.lastDuration || 0,
                        reviewHistory: [...(reviewHistory || []), quality].slice(-20)
                    };
                    return { data: newData, metrics: this._calculateMetrics(newData, quality) };
                }

                _calculateAnki(quality, currentData) {
                    const { repetition = 0, easeFactor = DEFAULTS.DEFAULT_EASE_FACTOR, interval = 0, lapses = 0, reviewHistory = [] } = currentData;
                    let newEaseFactor = easeFactor, newRepetition = repetition, newInterval;
                    switch (quality) {
                        case ReviewQuality.AGAIN:
                            newInterval = 1; newRepetition = 0; newEaseFactor = Math.max(DEFAULTS.MIN_EASE_FACTOR, easeFactor - DEFAULTS.EASE_PENALTY); break;
                        case ReviewQuality.HARD:
                            newInterval = Math.max(1, Math.round(interval * DEFAULTS.HARD_MULTIPLIER)); newRepetition = repetition + 1; newEaseFactor = Math.max(DEFAULTS.MIN_EASE_FACTOR, easeFactor - DEFAULTS.HARD_PENALTY); break;
                        case ReviewQuality.GOOD:
                            if (repetition === 0) newInterval = 1;
                            else if (repetition === 1) newInterval = 6;
                            else newInterval = Math.round(interval * easeFactor);
                            newRepetition = repetition + 1;
                            break;
                        case ReviewQuality.EASY:
                            if (repetition === 0) newInterval = 4;
                            else newInterval = Math.round(interval * easeFactor * DEFAULTS.EASY_MULTIPLIER);
                            newRepetition = repetition + 1;
                            newEaseFactor = Math.min(DEFAULTS.MAX_EASE_FACTOR, easeFactor + DEFAULTS.EASE_BONUS);
                            break;
                        default: throw new Error('Ú©ÛŒÙÛŒØª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ú©ÛŒ');
                    }
                    if (this.config.enableFuzzing && newInterval > 10) newInterval = this._applyFuzzing(newInterval);
                    newInterval = Math.min(newInterval, this.config.maxInterval);
                    const newData = {
                        repetition: newRepetition,
                        easeFactor: Number(newEaseFactor.toFixed(2)),
                        interval: newInterval,
                        lapses: quality === 0 ? lapses + 1 : lapses,
                        lastDuration: currentData.lastDuration || 0,
                        reviewHistory: [...(reviewHistory || []), quality].slice(-20)
                    };
                    return { data: newData, metrics: this._calculateMetrics(newData, quality) };
                }

                _calculateFSRS(quality, currentData) {
                    const { repetition = 0, interval = 0, lapses = 0, reviewHistory = [] } = currentData;
                    const FSRS_CONSTANTS = { w0: 0.4, w1: 0.6, decay: 0.5 };
                    const avgQuality = reviewHistory.length > 0 ? reviewHistory.reduce((a, b) => a + b, 0) / reviewHistory.length : 3;
                    const difficulty = Math.max(0, Math.min(1, 1 - (avgQuality / 5)));
                    let stability = repetition === 0 ? FSRS_CONSTANTS.w0 : interval * Math.pow(1 + FSRS_CONSTANTS.decay, -repetition);
                    let newStability, newDifficulty;
                    if (quality >= 3) {
                        newStability = stability * (1 + (quality / 5) * FSRS_CONSTANTS.w1);
                        newDifficulty = Math.max(0, difficulty - 0.1);
                    } else {
                        newStability = stability * DEFAULTS.AGAIN_MULTIPLIER;
                        newDifficulty = Math.min(1, difficulty + 0.2);
                    }
                    let newInterval = Math.round(newStability * 30);
                    if (repetition === 0) newInterval = 1;
                    newInterval = Math.min(newInterval, this.config.maxInterval);
                    const newEaseFactor = Math.max(DEFAULTS.MIN_EASE_FACTOR, Math.min(DEFAULTS.MAX_EASE_FACTOR, newStability * 2));
                    const newData = {
                        repetition: repetition + 1,
                        easeFactor: Number(newEaseFactor.toFixed(2)),
                        interval: newInterval,
                        lapses: quality < 3 ? lapses + 1 : lapses,
                        lastDuration: currentData.lastDuration || 0,
                        reviewHistory: [...(reviewHistory || []), quality].slice(-20)
                    };
                    const metrics = {
                        retention: Math.exp(-interval / (stability * 30)),
                        stability: newStability,
                        difficulty: newDifficulty,
                        ...this._calculateMetrics(newData, quality)
                    };
                    return { data: newData, metrics };
                }

                _validateInput(quality, currentData) {
                    if (quality < 0 || quality > 5) throw new Error('Ú©ÛŒÙÛŒØª Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† Û° ØªØ§ Ûµ Ø¨Ø§Ø´Ø¯');
                    if (!currentData || typeof currentData !== 'object') throw new Error('Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø§Ø±ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª');
                }

                _applyFuzzing(interval) {
                    const range = Math.max(1, Math.floor(interval * this.config.fuzzRange));
                    const offset = Math.floor(Math.random() * (range * 2 + 1)) - range;
                    return Math.max(1, interval + offset);
                }

                _calculateMetrics(data, quality) {
                    const retention = Math.exp(-data.interval / (data.easeFactor * 10));
                    const stability = data.interval * data.easeFactor;
                    const lapseRate = data.reviewHistory.length > 0 ? data.reviewHistory.filter(q => q < 3).length / data.reviewHistory.length : 0.5;
                    const difficulty = Math.min(1, lapseRate * 1.5);
                    return { retention: Number(retention.toFixed(3)), stability: Number(stability.toFixed(1)), difficulty: Number(difficulty.toFixed(2)) };
                }

                getNextReviewDate(intervalDays, fromDate = new Date()) {
                    const date = new Date(fromDate); date.setDate(date.getDate() + intervalDays); return date;
                }

                isDue(card, now = new Date()) {
                    if (!card || !card.nextReview) return true; return new Date(card.nextReview) <= now;
                }

                resetCard(baseData = {}) {
                    return { repetition: 0, easeFactor: DEFAULTS.DEFAULT_EASE_FACTOR, interval: 0, lapses: 0, lastDuration: 0, reviewHistory: [], ...baseData };
                }
            }

            // ==================== ØªØ³Øªâ€ŒÙ‡Ø§ ====================
            const card0 = { repetition: 0, easeFactor: 2.5, interval: 0, lapses: 0, reviewHistory: [] };
            const card1 = { repetition: 1, easeFactor: 2.5, interval: 1, lapses: 0, reviewHistory: [5] };
            const card2 = { repetition: 2, easeFactor: 2.5, interval: 6, lapses: 0, reviewHistory: [5, 5] };
            const card3 = { repetition: 3, easeFactor: 2.8, interval: 15, lapses: 0, reviewHistory: [5, 5, 5] };

            const tests = {
                sm2: [
                    { name: 'SM-2: Ú©ÛŒÙÛŒØª Ûµ Ø¨Ø§ Ú©Ø§Ø±Øª Ø¬Ø¯ÛŒØ¯', fn: () => { const e = new SRSEngine({ algorithm: 'sm2' }); const r = e.calculate(5, card0); return r.data.interval === 1 && r.data.repetition === 1 && r.data.easeFactor === 2.5; } },
                    { name: 'SM-2: Ú©ÛŒÙÛŒØª Û´ Ø¨Ø§ ØªÚ©Ø±Ø§Ø±=Û±', fn: () => { const e = new SRSEngine({ algorithm: 'sm2' }); const r = e.calculate(4, card1); return r.data.interval === 6 && r.data.repetition === 2; } },
                    { name: 'SM-2: Ú©ÛŒÙÛŒØª Û² (Ù¾Ø§Ø³Ø® ØºÙ„Ø·)', fn: () => { const e = new SRSEngine({ algorithm: 'sm2' }); const r = e.calculate(2, card2); return r.data.interval === 1 && r.data.repetition === 0; } }
                ],
                anki: [
                    { name: 'Anki: AGAIN (Ú©ÛŒÙÛŒØª Û°)', fn: () => { const e = new SRSEngine({ algorithm: 'anki' }); const r = e.calculate(0, card2); return r.data.interval === 1 && r.data.repetition === 0 && r.data.easeFactor < 2.5; } },
                    { name: 'Anki: HARD (Ú©ÛŒÙÛŒØª Û±)', fn: () => { const e = new SRSEngine({ algorithm: 'anki' }); const r = e.calculate(1, card2); return r.data.interval > 6 && r.data.repetition === 3; } },
                    { name: 'Anki: GOOD (Ú©ÛŒÙÛŒØª Û²)', fn: () => { const e = new SRSEngine({ algorithm: 'anki' }); const r = e.calculate(2, card2); return r.data.interval === 15 && r.data.repetition === 3; } },
                    { name: 'Anki: EASY (Ú©ÛŒÙÛŒØª Û³)', fn: () => { const e = new SRSEngine({ algorithm: 'anki' }); const r = e.calculate(3, card2); return r.data.interval > 15 && r.data.easeFactor > 2.5; } }
                ],
                fsrs: [
                    { name: 'FSRS: Ú©ÛŒÙÛŒØª Ûµ Ø¨Ø§ Ú©Ø§Ø±Øª Ø¬Ø¯ÛŒØ¯', fn: () => { const e = new SRSEngine({ algorithm: 'fsrs' }); const r = e.calculate(5, card0); return r.data.interval >= 1 && r.metrics.stability > 0; } },
                    { name: 'FSRS: Ú©ÛŒÙÛŒØª Û± (Ù¾Ø§Ø³Ø® ØºÙ„Ø·)', fn: () => { const e = new SRSEngine({ algorithm: 'fsrs' }); const r = e.calculate(1, card3); return r.metrics.difficulty > 0.5; } },
                    { name: 'FSRS: Ù…Ø­Ø§Ø³Ø¨Ù‡ retention', fn: () => { const e = new SRSEngine({ algorithm: 'fsrs' }); const r = e.calculate(5, card3); return r.metrics.retention > 0 && r.metrics.retention < 1; } }
                ],
                metrics: [
                    { name: 'ğŸ“ˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ retention Ù…Ø¹Ù‚ÙˆÙ„', fn: () => { const e = new SRSEngine(); const r = e.calculate(5, card3); return r.metrics.retention > 0.5 && r.metrics.retention < 1; } },
                    { name: 'ğŸ“ˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ stability Ù…Ø«Ø¨Øª', fn: () => { const e = new SRSEngine(); const r = e.calculate(5, card3); return r.metrics.stability > 0; } },
                    { name: 'ğŸ“ˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ difficulty Ø¨ÛŒÙ† Û°-Û±', fn: () => { const e = new SRSEngine(); const r = e.calculate(2, card3); return r.metrics.difficulty >= 0 && r.metrics.difficulty <= 1; } },
                    { name: 'ğŸ“ˆ isDue Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Øª Ø¨Ø§ nextReview', fn: () => { const e = new SRSEngine(); const tomorrow = new Date(Date.now() + 86400000).toISOString(); return e.isDue({ nextReview: tomorrow }) === false; } }
                ]
            };

            // ==================== Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª ====================
            window.runAllTests = function() {
                const containers = {
                    sm2: document.getElementById('test-list-sm2'),
                    anki: document.getElementById('test-list-anki'),
                    fsrs: document.getElementById('test-list-fsrs'),
                    metrics: document.getElementById('test-list-metrics')
                };

                let total = 0, passed = 0;

                for (let category in containers) {
                    containers[category].innerHTML = '';
                    tests[category].forEach(test => {
                        total++;
                        try {
                            const result = test.fn();
                            if (result) passed++;
                            const status = result ? 'pass' : 'fail';
                            const item = document.createElement('div');
                            item.className = 'test-item';
                            item.innerHTML = `
                                <div class="test-status ${status === 'pass' ? 'status-pass' : 'status-fail'}">${result ? 'âœ… PASS' : 'âŒ FAIL'}</div>
                                <div class="test-name">${test.name}</div>
                            `;
                            containers[category].appendChild(item);
                        } catch (e) {
                            const item = document.createElement('div');
                            item.className = 'test-item';
                            item.innerHTML = `
                                <div class="test-status status-fail">âš ï¸ ERROR</div>
                                <div class="test-name">${test.name}<div class="test-message">${e.message}</div></div>
                            `;
                            containers[category].appendChild(item);
                        }
                    });
                }

                document.getElementById('total').innerText = total;
                document.getElementById('passed').innerText = passed;
                document.getElementById('failed').innerText = total - passed;
            };

            window.onload = runAllTests;
        })();
    </script>
</body>
</html>
```
