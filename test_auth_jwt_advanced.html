<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farsinglish - ØªØ³Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡ JWT</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        .container { 
            max-width: 800px; 
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        h1 { 
            text-align: center; 
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .test-section { 
            margin: 25px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            border-left: 4px solid #4CAF50;
        }
        .test-header { 
            display: flex; 
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        .test-title { font-size: 1.2rem; font-weight: 600; }
        .test-result { 
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        .pass { background: #4CAF50; color: white; }
        .fail { background: #f44336; color: white; }
        .details { 
            margin-top: 10px;
            padding: 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .summary {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            text-align: center;
            font-size: 1.1rem;
        }
        button {
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .controls { text-align: center; margin-top: 20px; }
        @media (max-width: 600px) {
            .container { padding: 15px; }
            h1 { font-size: 1.8rem; }
            .test-header { flex-direction: column; align-items: flex-start; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” ØªØ³Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡ JWT - Farsinglish</h1>
        
        <div id="test-results">
            <!-- ØªØ³Øªâ€ŒÙ‡Ø§ Ø§ÛŒÙ†Ø¬Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ -->
        </div>
        
        <div class="summary">
            <p id="summary-text">ØªØ¹Ø¯Ø§Ø¯ ØªØ³Øªâ€ŒÙ‡Ø§: Û° | Ù…ÙˆÙÙ‚: Û° | Ù†Ø§Ù…ÙˆÙÙ‚: Û°</p>
        </div>
        
        <div class="controls">
            <button onclick="runAllTests()">ğŸš€ Ø§Ø¬Ø±Ø§ÛŒ ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§</button>
            <button onclick="clearTests()">ğŸ§¹ Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù†ØªØ§ÛŒØ¬</button>
        </div>
    </div>

    <script>
        class JWTService {
            constructor() {
                this.secretKey = 'farsinglish-secret-2025';
                this.tokenHeader = { alg: 'HS256', typ: 'JWT' };
            }

            base64UrlEncode(str) {
                return btoa(str)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');
            }

            base64UrlDecode(str) {
                str = str.replace(/-/g, '+').replace(/_/g, '/');
                while (str.length % 4) str += '=';
                return atob(str);
            }

            async createToken(payload, options = {}) {
                const header = this.base64UrlEncode(JSON.stringify(this.tokenHeader));
                const payloadWithExp = {
                    ...payload,
                    iat: Math.floor(Date.now() / 1000),
                    exp: Math.floor(Date.now() / 1000) + (options.expiresIn || 3600),
                    jti: this.generateJTI(),
                    iss: 'farsinglish-auth',
                    aud: 'farsinglish-app'
                };
                const encodedPayload = this.base64UrlEncode(JSON.stringify(payloadWithExp));
                const signature = await this.createSignature(`${header}.${encodedPayload}`);
                return `${header}.${encodedPayload}.${signature}`;
            }

            async createSignature(data) {
                const encoder = new TextEncoder();
                const key = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(this.secretKey),
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );
                const signature = await crypto.subtle.sign(
                    'HMAC',
                    key,
                    encoder.encode(data)
                );
                return this.base64UrlEncode(String.fromCharCode(...new Uint8Array(signature)));
            }

            async verifyToken(token) {
                try {
                    const parts = token.split('.');
                    if (parts.length !== 3) return { valid: false, error: 'ÙØ±Ù…Øª ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø±' };
                    
                    const [header, payload, signature] = parts;
                    const expectedSig = await this.createSignature(`${header}.${payload}`);
                    
                    if (signature !== expectedSig) {
                        return { valid: false, error: 'Ø§Ù…Ø¶Ø§ÛŒ ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø±' };
                    }
                    
                    const decodedPayload = JSON.parse(this.base64UrlDecode(payload));
                    const now = Math.floor(Date.now() / 1000);
                    
                    if (decodedPayload.exp && decodedPayload.exp < now) {
                        return { valid: false, error: 'ØªÙˆÚ©Ù† Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡', expired: true };
                    }
                    
                    if (decodedPayload.nbf && decodedPayload.nbf > now) {
                        return { valid: false, error: 'ØªÙˆÚ©Ù† Ù‡Ù†ÙˆØ² ÙØ¹Ø§Ù„ Ù†Ø´Ø¯Ù‡' };
                    }
                    
                    return {
                        valid: true,
                        payload: decodedPayload,
                        userId: decodedPayload.sub || decodedPayload.userId,
                        expiresIn: decodedPayload.exp - now
                    };
                } catch (error) {
                    return { valid: false, error: error.message };
                }
            }

            generateJTI() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            async refreshToken(oldToken, newExpiresIn = 3600) {
                const verification = await this.verifyToken(oldToken);
                if (!verification.valid) {
                    throw new Error(`ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø±: ${verification.error}`);
                }
                
                if (verification.expiresIn > 300) {
                    throw new Error('ØªÙˆÚ©Ù† Ù‡Ù†ÙˆØ² Ù…Ù†Ù‚Ø¶ÛŒ Ù†Ø´Ø¯Ù‡');
                }
                
                const newPayload = {
                    sub: verification.userId,
                    username: verification.payload.username,
                    role: verification.payload.role || 'user',
                    sessionId: verification.payload.sessionId
                };
                
                return this.createToken(newPayload, { expiresIn: newExpiresIn });
            }

            extractPayload(token) {
                try {
                    const parts = token.split('.');
                    if (parts.length !== 3) return null;
                    return JSON.parse(this.base64UrlDecode(parts[1]));
                } catch {
                    return null;
                }
            }

            validateClaims(payload, requiredClaims = ['sub', 'iat', 'exp']) {
                const missing = requiredClaims.filter(claim => !(claim in payload));
                if (missing.length > 0) {
                    return { valid: false, missing };
                }
                return { valid: true };
            }
        }

        const tests = [
            {
                id: 1,
                title: "ØªÙˆÙ„ÛŒØ¯ ØªÙˆÚ©Ù† Ø¨Ø§ Claims Ú©Ø§Ù…Ù„",
                run: async (jwt) => {
                    const payload = {
                        sub: "user-123",
                        username: "Ø¹Ù„ÛŒ Ù…Ø­Ù…Ø¯ÛŒ",
                        role: "premium",
                        sessionId: "sess-789"
                    };
                    const token = await jwt.createToken(payload, { expiresIn: 7200 });
                    const verification = await jwt.verifyToken(token);
                    
                    return verification.valid && 
                           verification.payload.sub === "user-123" &&
                           verification.payload.username === "Ø¹Ù„ÛŒ Ù…Ø­Ù…Ø¯ÛŒ" &&
                           verification.payload.role === "premium";
                }
            },
            {
                id: 2,
                title: "Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ØªÙˆÚ©Ù† Ø¨Ø§ Ø§Ù…Ø¶Ø§ÛŒ Ù†Ø§Ø¯Ø±Ø³Øª",
                run: async (jwt) => {
                    const payload = { sub: "user-456" };
                    const token = await jwt.createToken(payload);
                    const tamperedToken = token.slice(0, -5) + "xxxxx";
                    const verification = await jwt.verifyToken(tamperedToken);
                    return !verification.valid && verification.error.includes('Ø§Ù…Ø¶Ø§ÛŒ');
                }
            },
            {
                id: 3,
                title: "ØªØ´Ø®ÛŒØµ ØªÙˆÚ©Ù† Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡",
                run: async (jwt) => {
                    const payload = { sub: "user-789" };
                    const token = await jwt.createToken(payload, { expiresIn: -3600 });
                    const verification = await jwt.verifyToken(token);
                    return !verification.valid && verification.expired === true;
                }
            },
            {
                id: 4,
                title: "ØªØ¬Ø¯ÛŒØ¯ ØªÙˆÚ©Ù† (Refresh) Ù…ÙˆÙÙ‚",
                run: async (jwt) => {
                    const payload = { sub: "user-999", username: "ØªØ³Øª" };
                    const token = await jwt.createToken(payload, { expiresIn: 100 });
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    try {
                        const newToken = await jwt.refreshToken(token, 3600);
                        const verification = await jwt.verifyToken(newToken);
                        return verification.valid && verification.payload.sub === "user-999";
                    } catch {
                        return false;
                    }
                }
            },
            {
                id: 5,
                title: "Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Refresh ØªÙˆÚ©Ù† Ù…Ø¹ØªØ¨Ø±",
                run: async (jwt) => {
                    const payload = { sub: "user-111" };
                    const token = await jwt.createToken(payload, { expiresIn: 5000 });
                    
                    try {
                        await jwt.refreshToken(token);
                        return false;
                    } catch (error) {
                        return error.message.includes('ØªÙˆÚ©Ù† Ù‡Ù†ÙˆØ² Ù…Ù†Ù‚Ø¶ÛŒ Ù†Ø´Ø¯Ù‡');
                    }
                }
            },
            {
                id: 6,
                title: "Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Claims Ø¶Ø±ÙˆØ±ÛŒ",
                run: async (jwt) => {
                    const payload = { customField: "value" };
                    const token = await jwt.createToken(payload);
                    const verification = await jwt.verifyToken(token);
                    return verification.valid && 'sub' in verification.payload;
                }
            },
            {
                id: 7,
                title: "Ø§Ø³ØªØ®Ø±Ø§Ø¬ Payload Ø¨Ø¯ÙˆÙ† Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ",
                run: async (jwt) => {
                    const payload = { 
                        sub: "extract-test",
                        data: { score: 95, level: 5 }
                    };
                    const token = await jwt.createToken(payload);
                    const extracted = jwt.extractPayload(token);
                    return extracted && 
                           extracted.sub === "extract-test" &&
                           extracted.data.score === 95;
                }
            },
            {
                id: 8,
                title: "ØªÙˆÚ©Ù† Ø¨Ø§ Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§ÛŒ ÙØ§Ø±Ø³ÛŒ Ø¯Ø± Payload",
                run: async (jwt) => {
                    const payload = {
                        sub: "user-fa",
                        name: "Ù…Ø­Ù…Ø¯ Ø±Ø¶Ø§ÛŒÛŒ",
                        city: "ØªÙ‡Ø±Ø§Ù†",
                        bio: "Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒÙ†ÙˆÛŒØ³ Ùˆ Ø¹Ù„Ø§Ù‚Ù‡â€ŒÙ…Ù†Ø¯ Ø¨Ù‡ Ø¢Ù…ÙˆØ²Ø´ Ø²Ø¨Ø§Ù†"
                    };
                    const token = await jwt.createToken(payload);
                    const verification = await jwt.verifyToken(token);
                    return verification.valid && 
                           verification.payload.name === "Ù…Ø­Ù…Ø¯ Ø±Ø¶Ø§ÛŒÛŒ" &&
                           verification.payload.bio.includes("Ø¢Ù…ÙˆØ²Ø´ Ø²Ø¨Ø§Ù†");
                }
            },
            {
                id: 9,
                title: "ØªÙˆÚ©Ù† Ø¨Ø§ Not Before (nbf)",
                run: async (jwt) => {
                    const futureTime = Math.floor(Date.now() / 1000) + 3600;
                    const payload = {
                        sub: "user-nbf",
                        nbf: futureTime
                    };
                    const token = await jwt.createToken(payload, { expiresIn: 7200 });
                    const verification = await jwt.verifyToken(token);
                    return !verification.valid && 
                           verification.error.includes('ØªÙˆÚ©Ù† Ù‡Ù†ÙˆØ² ÙØ¹Ø§Ù„ Ù†Ø´Ø¯Ù‡');
                }
            },
            {
                id: 10,
                title: "ØªÙˆÚ©Ù† Ø¨Ø§ Issuer Ùˆ Audience",
                run: async (jwt) => {
                    const payload = { sub: "user-iss" };
                    const token = await jwt.createToken(payload);
                    const verification = await jwt.verifyToken(token);
                    return verification.valid && 
                           verification.payload.iss === "farsinglish-auth" &&
                           verification.payload.aud === "farsinglish-app";
                }
            },
            {
                id: 11,
                title: "JTI ÛŒÚ©ØªØ§ Ø¨Ø±Ø§ÛŒ Ù‡Ø± ØªÙˆÚ©Ù†",
                run: async (jwt) => {
                    const payload1 = { sub: "user-jti-1" };
                    const payload2 = { sub: "user-jti-2" };
                    
                    const token1 = await jwt.createToken(payload1);
                    const token2 = await jwt.createToken(payload2);
                    
                    const payloadObj1 = jwt.extractPayload(token1);
                    const payloadObj2 = jwt.extractPayload(token2);
                    
                    return payloadObj1 && payloadObj2 &&
                           payloadObj1.jti && payloadObj2.jti &&
                           payloadObj1.jti !== payloadObj2.jti;
                }
            },
            {
                id: 12,
                title: "ØªÙˆÚ©Ù† Ø¨Ø§ Custom Claims Ùˆ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ",
                run: async (jwt) => {
                    const payload = {
                        sub: "custom-user",
                        custom: {
                            premium: true,
                            subscriptionEnd: "2025-12-31",
                            features: ["vocab", "lessons", "speaking"]
                        }
                    };
                    const token = await jwt.createToken(payload);
                    const verification = await jwt.verifyToken(token);
                    
                    const claimsCheck = jwt.validateClaims(verification.payload, 
                        ['sub', 'iat', 'exp', 'jti', 'iss', 'aud']);
                    
                    return verification.valid && 
                           claimsCheck.valid &&
                           verification.payload.custom.premium === true &&
                           verification.payload.custom.features.includes("speaking");
                }
            }
        ];

        const jwtService = new JWTService();
        let passedTests = 0;
        let failedTests = 0;

        async function runAllTests() {
            passedTests = 0;
            failedTests = 0;
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '';
            
            for (const test of tests) {
                try {
                    const result = await test.run(jwtService);
                    const testDiv = document.createElement('div');
                    testDiv.className = 'test-section';
                    
                    const testResult = result ? 'pass' : 'fail';
                    const resultText = result ? 'âœ… Ù…ÙˆÙÙ‚' : 'âŒ Ù†Ø§Ù…ÙˆÙÙ‚';
                    
                    if (result) passedTests++;
                    else failedTests++;
                    
                    testDiv.innerHTML = `
                        <div class="test-header">
                            <div class="test-title">${test.id}. ${test.title}</div>
                            <div class="test-result ${testResult}">${resultText}</div>
                        </div>
                        <div class="details">
                            ${result ? 'ØªØ³Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø§Ø³ Ø´Ø¯' : 'ØªØ³Øª Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯'}
                        </div>
                    `;
                    
                    resultsDiv.appendChild(testDiv);
                } catch (error) {
                    failedTests++;
                    const testDiv = document.createElement('div');
                    testDiv.className = 'test-section';
                    testDiv.innerHTML = `
                        <div class="test-header">
                            <div class="test-title">${test.id}. ${test.title}</div>
                            <div class="test-result fail">âŒ Ø®Ø·Ø§</div>
                        </div>
                        <div class="details">Ø®Ø·Ø§: ${error.message}</div>
                    `;
                    resultsDiv.appendChild(testDiv);
                }
                
                updateSummary();
            }
        }

        function clearTests() {
            document.getElementById('test-results').innerHTML = '';
            passedTests = failedTests = 0;
            updateSummary();
        }

        function updateSummary() {
            const summary = document.getElementById('summary-text');
            summary.textContent = 
                `ØªØ¹Ø¯Ø§Ø¯ ØªØ³Øªâ€ŒÙ‡Ø§: ${tests.length} | Ù…ÙˆÙÙ‚: ${passedTests} | Ù†Ø§Ù…ÙˆÙÙ‚: ${failedTests}`;
        }

        window.onload = () => {
            updateSummary();
            console.log('âœ… ØªØ³Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡ JWT Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø¬Ø±Ø§ Ø§Ø³Øª');
        };
    </script>
</body>
  </html>
