<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØ³Øª Ø¯Ø³ØªÛŒ Timeout Ùˆ Retry - Farsinglish</title>
    <style>
        body { font-family: Tahoma, Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 15px; background: #f5f5f5; }
        .header { background: #2c3e50; color: white; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; }
        .test-card { background: white; border-radius: 10px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        button { background: #3498db; color: white; border: none; padding: 12px 25px; border-radius: 6px; font-size: 16px; cursor: pointer; margin: 5px; width: calc(50% - 10px); }
        button.small { width: auto; padding: 8px 15px; }
        .btn-success { background: #27ae60; }
        .btn-danger { background: #e74c3c; }
        .btn-warning { background: #f39c12; }
        .log { background: #34495e; color: #ecf0f1; padding: 15px; border-radius: 8px; font-family: monospace; height: 300px; overflow-y: auto; font-size: 14px; margin-top: 20px; }
        .log-entry { border-bottom: 1px solid #445566; padding: 5px 0; }
        .badge { background: #3498db; color: white; padding: 3px 8px; border-radius: 4px; font-size: 12px; margin-right: 5px; }
        .config-item { margin: 10px 0; padding: 10px; background: #ecf0f1; border-radius: 6px; }
        input { padding: 8px; border: 1px solid #bdc3c7; border-radius: 4px; width: 100px; margin: 0 5px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>â±ï¸ Farsinglish - ØªØ³Øª Ø¯Ø³ØªÛŒ Timeout Ùˆ Retry</h1>
        <h2>Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ ØªØ£Ø®ÛŒØ± Ø´Ø¨Ú©Ù‡ Ùˆ ØªÙ„Ø§Ø´ Ù…Ø¬Ø¯Ø¯</h2>
    </div>

    <div class="test-card">
        <h3>âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ³Øª</h3>
        <div class="config-item">
            <label>â±ï¸ Ø²Ù…Ø§Ù† ØªØ£Ø®ÛŒØ± Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒâ€ŒØ´Ø¯Ù‡ (ms):</label>
            <input type="number" id="delayInput" value="3000" min="0" max="10000" step="100">
            <span class="badge">Ù¾ÛŒØ´â€ŒÙØ±Ø¶: Û³Û°Û°Û° (Û³ Ø«Ø§Ù†ÛŒÙ‡)</span>
        </div>
        <div class="config-item">
            <label>ğŸ”„ Ø­Ø¯Ø§Ú©Ø«Ø± ØªØ¹Ø¯Ø§Ø¯ ØªÙ„Ø§Ø´ Ù…Ø¬Ø¯Ø¯:</label>
            <input type="number" id="maxRetriesInput" value="3" min="1" max="5">
            <span class="badge">Ù¾ÛŒØ´â€ŒÙØ±Ø¶: Û³ Ø¨Ø§Ø±</span>
        </div>
        <div class="config-item">
            <label>ğŸ“ˆ ÙØ§Ú©ØªÙˆØ± Ø§ÙØ²Ø§ÛŒØ´ ØªØ£Ø®ÛŒØ± (Backoff):</label>
            <input type="number" id="backoffInput" value="2" min="1" max="4" step="0.5">
            <span class="badge">Ù‡Ø± Ø¨Ø§Ø± Ã—Û²</span>
        </div>
    </div>

    <div class="test-card">
        <h3>ğŸ§ª Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§ÛŒ ØªØ³Øª</h3>
        <button class="btn-success" onclick="testSuccessfulRequest()">âœ… Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…ÙˆÙÙ‚</button>
        <button class="btn-warning" onclick="testTimeoutRequest()">â±ï¸ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Timeout</button>
        <button class="btn-danger" onclick="testServerError()">âŒ Ø®Ø·Ø§ÛŒ Ø³Ø±ÙˆØ± (ÛµÛ°Û°)</button>
        <button style="background: #9b59b6;" onclick="testNetworkError()">ğŸ“¶ Ù‚Ø·Ø¹ Ø´Ø¨Ú©Ù‡</button>
        <button onclick="testExponentialBackoff()">ğŸ“ˆ Backoff Ù†Ù…Ø§ÛŒÛŒ</button>
        <button onclick="testMaxRetriesExceeded()">âš ï¸ Ø§ØªÙ…Ø§Ù… ØªÙ„Ø§Ø´â€ŒÙ‡Ø§</button>
        <button onclick="clearLog()">ğŸ—‘ï¸ Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù„Ø§Ú¯</button>
    </div>

    <div class="test-card">
        <h3>ğŸ“‹ Ù„Ø§Ú¯ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§</h3>
        <div id="logContainer" class="log">
            <div class="log-entry">â±ï¸ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ ÛŒÚ© Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯...</div>
        </div>
    </div>

    <script>
        // -------------------- Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ø¨Ú©Ù‡ --------------------
        class NetworkSimulator {
            constructor() {
                this.retryCount = 0;
                this.abortController = null;
            }

            async simulateRequest(options = {}) {
                const {
                    delay = 3000,
                    shouldTimeout = false,
                    shouldError = false,
                    errorStatus = 500,
                    simulateNetworkError = false
                } = options;

                return new Promise((resolve, reject) => {
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù‚Ø·Ø¹ Ø´Ø¨Ú©Ù‡
                    if (simulateNetworkError) {
                        setTimeout(() => reject(new Error('ğŸŒ Ø§ØªØµØ§Ù„ Ø§ÛŒÙ†ØªØ±Ù†Øª Ù‚Ø·Ø¹ Ø´Ø¯')), 500);
                        return;
                    }

                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ timeout
                    if (shouldTimeout) {
                        setTimeout(() => reject(new Error('â±ï¸ Timeout: Ø³Ø±ÙˆØ± Ù¾Ø§Ø³Ø® Ù†Ø¯Ø§Ø¯')), delay);
                        return;
                    }

                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø®Ø·Ø§ÛŒ Ø³Ø±ÙˆØ±
                    if (shouldError) {
                        setTimeout(() => {
                            reject({
                                status: errorStatus,
                                message: errorStatus === 500 ? 'Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø³Ø±ÙˆØ±' : 'Ø®Ø·Ø§ÛŒ Ø³Ø±ÙˆØ±',
                                isServerError: true
                            });
                        }, delay / 2);
                        return;
                    }

                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§Ø³Ø® Ù…ÙˆÙÙ‚
                    setTimeout(() => {
                        resolve({
                            status: 200,
                            data: { message: 'Ù¾Ø§Ø³Ø® Ù…ÙˆÙÙ‚ Ø§Ø² Ø³Ø±ÙˆØ±', timestamp: Date.now() }
                        });
                    }, delay);
                });
            }

            async requestWithRetry(options = {}) {
                const {
                    maxRetries = 3,
                    baseDelay = 3000,
                    backoffFactor = 2,
                    scenario = 'success'
                } = options;

                this.retryCount = 0;
                let lastError = null;

                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        logMessage(`ğŸ”„ ØªÙ„Ø§Ø´ ${attempt}/${maxRetries}...`, 'info');
                        
                        // ØªÙ†Ø¸ÛŒÙ… Ø³Ù†Ø§Ø±ÛŒÙˆ
                        const simOptions = { delay: baseDelay };
                        
                        if (scenario === 'timeout' && attempt <= 2) {
                            simOptions.shouldTimeout = true;
                        } else if (scenario === 'serverError' && attempt <= 2) {
                            simOptions.shouldError = true;
                            simOptions.errorStatus = 500;
                        } else if (scenario === 'networkError' && attempt === 1) {
                            simOptions.simulateNetworkError = true;
                        } else if (scenario === 'backoff') {
                            // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ backoff Ù†Ù…Ø§ÛŒÛŒ
                            const backoffDelay = baseDelay * Math.pow(backoffFactor, attempt - 1);
                            logMessage(`â±ï¸ ØªØ£Ø®ÛŒØ± ${backoffDelay}ms (Backoff Ù†Ù…Ø§ÛŒÛŒ)`, 'info');
                            await this.delay(backoffDelay);
                            
                            if (attempt < maxRetries) {
                                throw new Error(`â±ï¸ Timeout Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒâ€ŒØ´Ø¯Ù‡ (ØªÙ„Ø§Ø´ ${attempt})`);
                            }
                        }

                        const response = await this.simulateRequest(simOptions);
                        logMessage(`âœ… ØªÙ„Ø§Ø´ ${attempt} Ù…ÙˆÙÙ‚: ${JSON.stringify(response.data)}`, 'success');
                        return response;

                    } catch (error) {
                        lastError = error;
                        logMessage(`âŒ ØªÙ„Ø§Ø´ ${attempt} Ù†Ø§Ù…ÙˆÙÙ‚: ${error.message || JSON.stringify(error)}`, 'error');
                        
                        if (attempt === maxRetries) {
                            logMessage(`âš ï¸ ØªÙ…Ø§Ù… ${maxRetries} ØªÙ„Ø§Ø´ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯`, 'warning');
                            throw error;
                        }

                        // Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ£Ø®ÛŒØ± Ù‚Ø¨Ù„ Ø§Ø² ØªÙ„Ø§Ø´ Ø¨Ø¹Ø¯ÛŒ
                        const retryDelay = baseDelay * Math.pow(backoffFactor, attempt - 1);
                        logMessage(`â³ ${retryDelay}ms ØªØ§ ØªÙ„Ø§Ø´ Ø¨Ø¹Ø¯ÛŒ...`, 'info');
                        await this.delay(retryDelay);
                    }
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        const simulator = new NetworkSimulator();

        // -------------------- ØªÙˆØ§Ø¨Ø¹ ØªØ³Øª --------------------
        async function testSuccessfulRequest() {
            logMessage('ğŸ§ª Ø´Ø±ÙˆØ¹ ØªØ³Øª Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…ÙˆÙÙ‚', 'test');
            try {
                const response = await simulator.requestWithRetry({
                    maxRetries: 1,
                    baseDelay: getDelay(),
                    scenario: 'success'
                });
                logMessage('ğŸ‰ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…ÙˆÙÙ‚ Ø¨Ø§ Ù¾Ø§Ø³Ø®: ' + JSON.stringify(response.data), 'success');
            } catch (error) {
                logMessage('âŒ Ø®Ø·Ø§: ' + error.message, 'error');
            }
        }

        async function testTimeoutRequest() {
            logMessage('ğŸ§ª Ø´Ø±ÙˆØ¹ ØªØ³Øª Timeout (Û² Ø¨Ø§Ø± Ø§ÙˆÙ„ timeoutØŒ Ø¨Ø§Ø± Ø³ÙˆÙ… Ù…ÙˆÙÙ‚)', 'test');
            try {
                const response = await simulator.requestWithRetry({
                    maxRetries: getMaxRetries(),
                    baseDelay: getDelay(),
                    scenario: 'timeout'
                });
                logMessage('ğŸ‰ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø³ Ø§Ø² timeout Ù…ÙˆÙÙ‚ Ø´Ø¯', 'success');
            } catch (error) {
                logMessage('âŒ ØªÙ…Ø§Ù… ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ Ø¨Ø§ timeout Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯', 'error');
            }
        }

        async function testServerError() {
            logMessage('ğŸ§ª Ø´Ø±ÙˆØ¹ ØªØ³Øª Ø®Ø·Ø§ÛŒ Ø³Ø±ÙˆØ± (ÛµÛ°Û°)', 'test');
            try {
                const response = await simulator.requestWithRetry({
                    maxRetries: getMaxRetries(),
                    baseDelay: getDelay(),
                    scenario: 'serverError'
                });
                logMessage('ğŸ‰ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø³ Ø§Ø² Ø®Ø·Ø§ÛŒ Ø³Ø±ÙˆØ± Ù…ÙˆÙÙ‚ Ø´Ø¯', 'success');
            } catch (error) {
                logMessage('âŒ ØªÙ…Ø§Ù… ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ Ø¨Ø§ Ø®Ø·Ø§ÛŒ Ø³Ø±ÙˆØ± Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯', 'error');
            }
        }

        async function testNetworkError() {
            logMessage('ğŸ§ª Ø´Ø±ÙˆØ¹ ØªØ³Øª Ù‚Ø·Ø¹ Ø´Ø¨Ú©Ù‡', 'test');
            try {
                const response = await simulator.requestWithRetry({
                    maxRetries: getMaxRetries(),
                    baseDelay: getDelay(),
                    scenario: 'networkError'
                });
                logMessage('ğŸ‰ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø³ Ø§Ø² Ù‚Ø·Ø¹ Ø´Ø¨Ú©Ù‡ Ù…ÙˆÙÙ‚ Ø´Ø¯', 'success');
            } catch (error) {
                logMessage('âŒ ØªÙ…Ø§Ù… ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ Ø¨Ø§ Ù‚Ø·Ø¹ Ø´Ø¨Ú©Ù‡ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯', 'error');
            }
        }

        async function testExponentialBackoff() {
            logMessage('ğŸ§ª Ø´Ø±ÙˆØ¹ ØªØ³Øª Backoff Ù†Ù…Ø§ÛŒÛŒ (Ø§ÙØ²Ø§ÛŒØ´ ØªØ£Ø®ÛŒØ±)', 'test');
            const start = Date.now();
            try {
                await simulator.requestWithRetry({
                    maxRetries: 3,
                    baseDelay: 1000,
                    backoffFactor: getBackoffFactor(),
                    scenario: 'backoff'
                });
            } catch (error) {
                const duration = ((Date.now() - start) / 1000).toFixed(1);
                logMessage(`ğŸ“Š Ù…Ø¬Ù…ÙˆØ¹ Ø²Ù…Ø§Ù†: ${duration} Ø«Ø§Ù†ÛŒÙ‡ (ØªØ£Ø®ÛŒØ±Ù‡Ø§: Û±, ${getBackoffFactor()}, ${getBackoffFactor()*2} Ø«Ø§Ù†ÛŒÙ‡)`, 'info');
            }
        }

        async function testMaxRetriesExceeded() {
            logMessage('ğŸ§ª Ø´Ø±ÙˆØ¹ ØªØ³Øª Ø§ØªÙ…Ø§Ù… ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ (Ù‡Ù…Ù‡ timeout)', 'test');
            try {
                const response = await simulator.requestWithRetry({
                    maxRetries: 3,
                    baseDelay: 1000,
                    scenario: 'timeout'
                });
            } catch (error) {
                logMessage('âš ï¸ ØªØ³Øª Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±: ØªÙ…Ø§Ù… Û³ ØªÙ„Ø§Ø´ timeout Ø´Ø¯', 'warning');
            }
        }

        // -------------------- ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ --------------------
        function getDelay() {
            return parseInt(document.getElementById('delayInput').value) || 3000;
        }

        function getMaxRetries() {
            return parseInt(document.getElementById('maxRetriesInput').value) || 3;
        }

        function getBackoffFactor() {
            return parseFloat(document.getElementById('backoffInput').value) || 2;
        }

        function logMessage(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            let icon = 'ğŸ“Œ';
            let color = '#3498db';
            
            if (type === 'success') { icon = 'âœ…'; color = '#27ae60'; }
            else if (type === 'error') { icon = 'âŒ'; color = '#e74c3c'; }
            else if (type === 'warning') { icon = 'âš ï¸'; color = '#f39c12'; }
            else if (type === 'test') { icon = 'ğŸ§ª'; color = '#9b59b6'; }
            
            const time = new Date().toLocaleTimeString('fa-IR');
            entry.innerHTML = `<span style="color: ${color}">${icon}</span> [${time}] ${message}`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }

        function clearLog() {
            const container = document.getElementById('logContainer');
            container.innerHTML = '<div class="log-entry">â±ï¸ Ù„Ø§Ú¯ Ù¾Ø§Ú© Ø´Ø¯...</div>';
        }
    </script>
</body>
</html>
